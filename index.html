<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jukebox V54 Library Plus</title>
    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2ecc71">
    <link rel="icon" type="image/png" href="assets/icons/icon.png">
    <link rel="apple-touch-icon" href="assets/icons/icon.png">

    <style>
        /* --- GRUNDDESIGN --- */
        :root {
            --bg-color: #f4f7f6;
            --green-safe: #2ecc71;
            --orange-warn: #f1c40f;
            --red-danger: #ff4757;
            --blue-time: #3498db;
            --purple-admin: #9b59b6;
            --yellow-btn: #f1c40f;
            --blue-btn: #3498db;
            --purple-btn: #9b59b6;
            --btn-color: #dfe4ea;
            --text: #2f3542;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text);
            margin: 0; height: 100vh; overflow: hidden;
            display: flex; flex-direction: column;
            user-select: none; -webkit-tap-highlight-color: transparent;
        }

        /* SCHWARZER VORHANG F√úR ECO MODUS */
        #black-curtain {
            display: none;
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: black;
            z-index: 99999;
            pointer-events: auto;
        }

        /* KIDS MODE UI */
        #kids-mode {
            display: none; 
            position: fixed; 
            top: 0; left: 0; right: 0; bottom: 0;
            width: 100%; height: 100%;
            flex-direction: column;
            align-items: center; justify-content: flex-start;
            background-color: #2c3e50; /* Dunkler Fallback */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            padding: 20px; padding-top: 60px; /* Mehr Platz oben f√ºr Titel */
            box-sizing: border-box;
            transition: background 0.3s ease;
            z-index: 50; 
            overflow-y: auto; 
        }
        
        .kids-text-shadow {
            text-shadow: 0 1px 3px rgba(255,255,255, 0.8);
            background: rgba(255, 255, 255, 0.65);
            padding: 5px 15px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: inline-block;
        }

        #track-title-display {
            font-size: 2.2rem; font-weight: 800; color: #2c3e50;
            margin-bottom: 20px; text-align: center; width: 95%;
            line-height: 1.1; 
            display: -webkit-box; -webkit-line-clamp: 3; 
            -webkit-box-orient: vertical; overflow: hidden; 
            white-space: normal; min-height: 6.5rem; 
            margin-top: 10px; /* Abstand zum Library Button */
        }
        
        #playlist-info {
            font-size: 1rem; color: #f1f2f6; text-shadow: 0 1px 2px black;
            margin-top: -15px; margin-bottom: 10px; font-weight: bold;
            max-width: 90%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }

        #album-art-container {
            width: 45vw; height: 45vw; border-radius: 20px;
            margin-bottom: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            background-color: #eee; overflow: hidden;
            display: flex; align-items: center; justify-content: center;
            border: 4px solid white; position: relative;
        }

        #album-img { width: 100%; height: 100%; object-fit: cover; display: none; }
        #album-placeholder { font-size: 60px; color: #ccc; }

        #sleep-indicator {
            position: absolute; top: 10px; right: 10px; font-size: 16px;
            background: rgba(255,255,255,0.9); padding: 5px 10px;
            border-radius: 12px; display: none; color: #333;
            font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.1); 
        }

        /* CONTROLS */
        .controls-main {
            display: flex; align-items: center; justify-content: center;
            gap: 25px; margin-bottom: 15px; width: 100%;
        }

        #volume-display-container {
            width: 85%; height: 25px; background-color: rgba(255,255,255,0.7);
            border-radius: 15px; overflow: hidden; border: 1px solid rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        #volume-bar {
            height: 100%; width: 50%; background-color: var(--green-safe);
            transition: width 0.2s, background-color 0.5s;
        }

        .controls-nav-row {
            display: flex; align-items: center; justify-content: center;
            gap: 20px; width: 100%; margin-bottom: 40px; 
        }
        
        .btn-control {
            border: none; border-radius: 50%; cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.15); display: flex;
            align-items: center; justify-content: center; font-weight: bold;
            transition: transform 0.1s; color: #576574; 
        }

        .btn-control:active { transform: scale(0.92); }
        .btn-control svg { width: 50%; height: 50%; fill: currentColor; }

        .btn-play {
            width: 110px; height: 110px; background-color: var(--green-safe); color: white;
        }
        .btn-play svg { width: 60%; height: 60%; }

        .btn-secondary {
            width: 75px; height: 75px; background-color: var(--btn-color); color: #2f3542;
        }

        .btn-colorful-vol-down { background-color: var(--yellow-btn) !important; color: #333 !important; }
        .btn-colorful-vol-up { background-color: var(--red-danger) !important; color: white !important; }
        .btn-colorful-back { background-color: var(--blue-btn) !important; color: white !important; }
        .btn-colorful-skip { background-color: var(--purple-btn) !important; color: white !important; }
        .btn-colorful-next { background-color: #00cec9 !important; color: white !important; }

        #time-container {
            width: 90%; height: 45px; background-color: rgba(255,255,255, 0.8);
            border-radius: 12px; position: relative; overflow: hidden;
            border: 1px solid rgba(0,0,0,0.1); cursor: pointer; margin-top: auto; 
            margin-bottom: 20px;
        }
        #time-progress { height: 100%; width: 0%; background-color: var(--blue-time); transition: width 0.5s linear; }
        #time-text {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            color: #2c3e50; font-weight: bold; font-size: 1.3rem;
            text-shadow: 0 0 2px rgba(255,255,255,0.8);
            font-variant-numeric: tabular-nums;
        }
        
        /* --- LIBRARY MODE (TIGERBOX STYLE) --- */
        #library-mode {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #2c3e50;
            z-index: 60; /* √úber Kids Mode */
            overflow-y: auto;
            flex-direction: column;
            padding: 20px; box-sizing: border-box;
            /* Layout Fix: Padding oben erh√∂ht, damit nichts verdeckt wird */
            padding-top: 40px; 
            padding-bottom: 90px;
        }

        .lib-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; margin-top: 10px;
        }

        .lib-title {
            color: white; font-size: 1.5rem; font-weight: bold; text-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        /* Filter Leiste */
        .filter-scroll-container {
            display: flex; gap: 10px; overflow-x: auto; 
            padding-bottom: 15px; /* Platz f√ºr Schatten */
            padding-top: 5px;
            margin-bottom: 10px;
            scrollbar-width: none;
        }
        .filter-scroll-container::-webkit-scrollbar { display: none; }

        .filter-chip {
            background: rgba(255,255,255,0.2); color: white;
            padding: 8px 16px; border-radius: 20px; white-space: nowrap;
            font-size: 0.9rem; border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.2s; cursor: pointer;
        }
        .filter-chip.active {
            background: var(--green-safe); border-color: var(--green-safe); font-weight: bold;
            box-shadow: 0 4px 10px rgba(46, 204, 113, 0.4);
        }

        /* Recent Section */
        .section-title { color: #dfe6e9; font-size: 1.1rem; margin-bottom: 10px; margin-top: 10px; font-weight: bold;}
        
        .recent-grid {
            display: flex; gap: 15px; overflow-x: auto; padding-bottom: 15px; margin-bottom: 10px;
        }
        .recent-card {
            min-width: 120px; width: 120px; display: flex; flex-direction: column; gap: 5px; position: relative;
        }

        /* Main Grid */
        .library-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 15px;
        }

        .lib-card {
            background: white; border-radius: 15px; overflow: hidden;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: transform 0.1s; position: relative;
        }
        .lib-card:active { transform: scale(0.96); }

        .lib-cover-wrap {
            width: 100%; aspect-ratio: 1 / 1; background: #eee;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden; position: relative;
        }
        .lib-cover-img { width: 100%; height: 100%; object-fit: cover; }
        .lib-placeholder { font-size: 40px; }

        .lib-card-body { padding: 10px; }
        .lib-card-title {
            font-size: 0.9rem; font-weight: bold; color: #2d3436;
            display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;
            line-height: 1.2; height: 2.4em;
        }
        .lib-meta-tag {
            font-size: 0.7rem; color: #636e72; margin-top: 5px; display: block;
        }

        /* INFO BUTTON AUF KARTE */
        .lib-card-info-btn {
            position: absolute; top: 8px; right: 8px;
            width: 30px; height: 30px; border-radius: 50%;
            background: rgba(255,255,255,0.9);
            color: #2980b9; border: none;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-family: serif; font-size: 1.1rem; font-style: italic;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 5;
        }

        /* Floating Close Button */
        #btn-close-lib {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--red-danger); color: white;
            padding: 15px 30px; border-radius: 30px; border: none;
            font-size: 1.1rem; font-weight: bold; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 70;
        }

        /* Button im Kids Mode um Library zu √∂ffnen */
        #btn-open-lib {
            position: absolute; top: 20px; left: 20px;
            background: rgba(255,255,255,0.25); color: white;
            border: none; width: 55px; height: 55px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(5px); z-index: 55;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        /* INFO MODAL */
        #lib-info-modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 80;
            align-items: center; justify-content: center; padding: 20px; box-sizing: border-box;
        }
        .info-modal-content {
            background: white; width: 100%; max-width: 400px; max-height: 80vh;
            border-radius: 20px; padding: 25px; overflow-y: auto;
            position: relative; text-align: center;
        }
        .info-modal-cover {
            width: 120px; height: 120px; border-radius: 10px; object-fit: cover;
            margin-bottom: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .info-modal-h { font-size: 1.2rem; font-weight: bold; color: #2c3e50; margin-bottom: 5px; }
        .info-modal-meta { color: #7f8c8d; font-size: 0.9rem; margin-bottom: 15px; }
        .info-modal-desc { 
            text-align: left; font-size: 0.95rem; line-height: 1.5; color: #34495e; 
            background: #f7f9fa; padding: 15px; border-radius: 10px;
        }
        .btn-close-modal {
            background: #2ecc71; color: white; border: none; padding: 10px 20px;
            border-radius: 20px; margin-top: 20px; font-weight: bold; width: 100%;
        }

        /* PARENT MODE UI */
        #parent-mode {
            display: flex; flex-direction: column; padding: 20px;
            height: 100vh; background-color: #2d3436; color: white;
            overflow-y: auto;
            z-index: 10;
        }

        .card {
            background: rgba(255,255,255,0.1); padding: 15px;
            border-radius: 10px; margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .card.editing-highlight {
            border: 2px solid #3498db;
            background: rgba(52, 152, 219, 0.1);
        }

        h2 { margin-top: 0; font-size: 1.1rem; color: #74b9ff; }

        input[type="file"], input[type="text"], select {
            width: 100%; padding: 12px; background: rgba(0,0,0,0.3);
            border: 1px solid #555; border-radius: 5px; color: white;
            box-sizing: border-box; margin-bottom: 10px;
        }
        input[type="color"] {
            width: 100%; height: 50px; padding: 5px; background: none; border: 1px solid #555; cursor: pointer;
        }

        .checkbox-wrapper { display: flex; align-items: center; margin-bottom: 15px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px;}
        .checkbox-wrapper input { width: auto; margin-right: 15px; transform: scale(1.5); }
        .checkbox-wrapper span { font-size: 0.9em; }

        label { display: block; margin-bottom: 5px; font-size: 0.9em; color: #aaa; }
        
        .file-info { font-size: 0.8em; color: #00cec9; margin-top:-5px; margin-bottom: 10px; display: block; font-style: italic; }

        button.btn-admin {
            background-color: #74b9ff; border: none; padding: 12px;
            border-radius: 8px; color: #2d3436; font-weight: bold;
            font-size: 16px; width: 100%; margin-top: 10px; cursor: pointer;
        }

        .btn-io-group { display: flex; gap: 10px; margin-top: 10px; }
        .btn-export { background-color: var(--purple-admin); color: white; }
        .btn-import { background-color: var(--green-safe); color: white; position: relative;}
        .btn-relink { background-color: var(--orange-warn); color: #333; position: relative; margin-top:10px; width: 100%;}
        
        #import-file-hidden, #relink-file-hidden, #bg-img-hidden, #bulk-folder-input, #repair-folder-input {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0; cursor: pointer;
        }

        .btn-switch-kids {
            background-color: var(--green-safe); color: white; padding: 15px;
            border: none; border-radius: 10px; font-size: 1.2rem;
            font-weight: bold; width: 100%; margin-bottom: 15px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .hint-text {
            background: rgba(255, 165, 2, 0.2); padding: 10px;
            border-radius: 5px; font-size: 0.85em; margin-bottom: 20px;
            border-left: 3px solid orange;
        }
        
        .warn-text {
            background: rgba(231, 76, 60, 0.2); padding: 10px;
            border-radius: 5px; font-size: 0.85em; margin-top: 5px; margin-bottom: 15px;
            border-left: 3px solid #e74c3c; color: #e74c3c; font-weight: bold;
        }
        
        .info-box-blue {
            background: rgba(52, 152, 219, 0.2); padding: 10px;
            border-radius: 5px; font-size: 0.85em; margin-bottom: 10px;
            border-left: 3px solid #3498db; color: #dfe6e9;
        }

        .footer-info {
            margin-top: auto; padding-top: 20px; padding-bottom: 20px;
            text-align: center; font-size: 0.75em; color: #888;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        .footer-info a { color: #74b9ff; text-decoration: none; }
        .footer-info a:hover { text-decoration: underline; }

        .tag-list-item {
            background: rgba(0,0,0,0.3); padding: 15px; margin-top: 5px;
            border-radius: 5px; font-size: 0.9em; display: flex;
            flex-direction: column; gap: 5px;
        }
        .tag-info-row { display: flex; align-items: center; justify-content: space-between; }
        .tag-action-row { display: flex; gap: 5px; margin-top: 5px;}

        .btn-fix-audio {
            background-color: #f1c40f; color: #333; border: none;
            padding: 5px 10px; border-radius: 4px; font-size: 0.8em;
            cursor: pointer; position: relative;
        }
        .btn-edit { background-color: #3498db; color: white; }
        .missing-audio-badge { color: #ff4757; font-weight: bold; font-size: 0.8em; }

        #mode-switch-secret { position: fixed; top: 0; right: 0; width: 80px; height: 80px; z-index: 9999; }

        #status-msg {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.9); color: white; padding: 10px 20px;
            border-radius: 30px; display: none; z-index: 1000; text-align: center;
        }

        #flash-overlay {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(46, 204, 113, 0.5); pointer-events: none;
            opacity: 0; transition: opacity 0.2s; z-index: 2000;
        }

        .browser-warning {
            background-color: #ff4757; color: white; padding: 15px;
            border-radius: 10px; margin-bottom: 20px; display: none;
        }

        /* Hilfsklasse zum Verstecken von Design-Optionen */
        .hidden-container { display: none; }
        
        #stubborn-video {
            position: fixed; top: 0; left: 0; width: 1px; height: 1px; opacity: 0.01; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="black-curtain"></div>
    
    <video id="stubborn-video" playsinline muted loop style="position:fixed; top:0; left:0; width:1px; height:1px; opacity:0.01; pointer-events:none;"></video>

    <div id="mode-switch-secret" onclick="handleSecretSwitch()"></div>
    
    <div id="flash-overlay"></div>

    <div id="parent-mode">
        <button class="btn-switch-kids" onclick="goToKidsMode()">‚ñ∂ ZUM KINDER-MODUS</button>
        <div class="hint-text">üí° Tipp: 5x oben rechts tippen f√ºr Admin-Men√º.</div>
        
        <h1>üîß Jukebox V54</h1>
        <div id="nfc-warning" class="browser-warning">‚ö†Ô∏è NFC API nicht verf√ºgbar. Bitte Chrome nutzen.</div>

        <div class="card">
            <h2>‚öôÔ∏è Einstellungen</h2>
            <label>Start-Modus:</label>
            <select id="start-mode-input" onchange="saveSettings()" style="background: rgba(46, 204, 113, 0.2); border: 1px solid #2ecc71;">
                <option value="parent">Eltern-Modus (Standard)</option>
                <option value="kids">Direkt Kinder-Modus</option>
            </select>

            <label>Maximale Lautst√§rke (Begrenzung):</label>
            <input type="range" id="max-vol-input" min="1" max="100" value="100" style="width:100%" oninput="updateSettingsUI()">
            <div style="display:flex; justify-content: space-between; align-items:center; margin-bottom: 5px;">
                 <span id="vol-display" style="font-size: 0.9em; font-weight:bold;">100%</span>
                 
                 <button class="btn-admin" style="width: auto; margin:0; padding: 5px 15px; background-color: #fab1a0; color: #333; font-size: 0.8em;" onclick="playTestTone()">
                    üîä Test-Ton (Limit)
                 </button>
            </div>
            
            <div class="warn-text">
                ‚ö†Ô∏è Wichtig: Bitte stelle die Handy-Lautst√§rke (Hardware-Tasten) auf 100%.
            </div>
            
            <label>Schlaf-Timer:</label>
            <select id="sleep-timer-input" onchange="saveSettings()" style="margin-bottom: 15px;">
                <option value="0">Aus (Endlos)</option>
                <option value="10">10 Minuten</option>
                <option value="20">20 Minuten</option>
                <option value="30">30 Minuten</option>
                <option value="60">1 Stunde</option>
            </select>
        </div>

        <div class="card" style="border-left: 3px solid #0984e3;">
            <h2>üîã Energie & Display</h2>
            <div class="checkbox-wrapper">
                <input type="checkbox" id="check-wakelock" onchange="saveSettings()">
                <div><strong>Display anlassen</strong><br><span style="font-size:0.8em; color:#ccc;">Nutzt Video-Trick + WakeLock</span></div>
            </div>
            <div class="checkbox-wrapper">
                <input type="checkbox" id="check-ecomode" onchange="updateEcoModeState(true)">
                <div><strong>Stromsparen beim Umdrehen</strong><br><span style="font-size:0.8em; color:#ccc;">Display aus bei Face-down</span></div>
            </div>
            <button class="btn-admin" style="background-color: #74b9ff; font-size: 0.9em; margin-top:0;" onclick="requestIOSPermission()">
                üì± iOS Sensoren aktivieren
            </button>
        </div>

        <div class="card" style="border-left: 3px solid #e84393;">
            <h2>üé® Design f√ºr Kinder-Modus</h2>
            <div class="checkbox-wrapper">
                <input type="checkbox" id="check-enable-lib" onchange="saveSettings()">
                <div><strong>üìö Bibliothek im Kinder-Modus erlauben</strong><br><span style="font-size:0.8em; color:#ccc;">Deaktivieren f√ºr reine Tag-Steuerung</span></div>
            </div>
            <div class="checkbox-wrapper">
                <input type="checkbox" id="check-colorful" onchange="saveSettings()">
                <span>üé® Bunte Kn√∂pfe f√ºr Kinder</span>
            </div>
            <label>Hintergrund-Modus:</label>
            <select id="bg-mode-select" onchange="updateBgUIState(); saveSettings();" style="margin-bottom: 15px;">
                <option value="default">Standard</option>
                <option value="color">Farbe</option>
                <option value="image">Bild</option>
            </select>
            <div id="bg-color-container" class="hidden-container"> 
                 <input type="color" id="bg-color-input" value="#ffffff" onchange="saveSettings()">
            </div>
            <div id="bg-image-container" class="hidden-container">
                <button class="btn-admin" style="background-color: #6c5ce7; position:relative;">
                    üñºÔ∏è Bild hochladen...
                    <input type="file" id="bg-img-hidden" accept="image/*" onchange="saveBackgroundImage(this)">
                </button>
                <button class="btn-admin" style="background-color: #ff7675; margin-top:5px;" onclick="deleteBackgroundImage()">L√∂schen</button>
            </div>
        </div>

        <div class="card" id="scan-card">
            <h2 id="form-title">üéµ Neuen Tag anlernen</h2>
            
            <label>1. Audio Datei(en)</label>
            <span id="audio-info" class="file-info"></span>
            <input type="file" id="audio-input" multiple accept="audio/*, .m4a, .mp3, .ogg, .wav, .flac" onchange="autoFillName()">
            
            <label>2. Cue-Datei (Optional)</label>
            <span id="cue-info" class="file-info"></span>
            <input type="file" id="cue-input" accept=".cue">

            <label>3. Cover Bild</label>
            <span id="img-info" class="file-info"></span>
            <input type="file" id="img-input" accept="image/*">
            
            <label>4. Name</label>
            <input type="text" id="track-name" placeholder="Name...">
            
            <div style="display:flex; gap:10px; flex-direction:column;">
                <button id="btn-save-tag" class="btn-admin" onclick="activateLinkMode()">üì° Tag scannen & speichern</button>
                <button id="btn-save-manual" class="btn-admin" style="background-color:#7f8c8d; margin-top:0;" onclick="saveManualTrack()">üíæ Ohne NFC speichern</button>
                <button id="btn-cancel-edit" class="btn-admin" style="background-color:#95a5a6; display:none;" onclick="cancelEdit()">Abbrechen</button>
            </div>
            <p id="scan-status" style="color: #74b9ff; margin-top: 10px; font-weight:bold; min-height: 20px;"></p>
        </div>

        <div class="card">
            <h2>üíæ Gespeicherte Tags</h2>
            <div id="tag-list"></div>
        </div>

        <div class="card">
            <h2>üìÇ Datenbank</h2>
            
            <div class="info-box-blue">
                <strong>‚ÑπÔ∏è Hybrid-Import:</strong><br>
                1. Sucht nach <code>jukebox.json</code> f√ºr perfekte Daten.<br>
                2. Fragt nach "restlichen" MP3s im Ordner (Achtung: Cover & Cue m√ºssen <u>exakt</u> wie MP3 hei√üen).<br>
                3. Browser "Upload" best√§tigen (Daten bleiben lokal!).
            </div>

            <button class="btn-admin" style="background-color: #e67e22; position:relative; margin-bottom:10px;">
                üìÇ Massen-Import (Ordner)
                <input type="file" id="bulk-folder-input" webkitdirectory directory multiple onchange="handleBulkImport(this)">
            </button>
            
            <div class="btn-io-group">
                <button class="btn-admin btn-export" onclick="exportJukeboxJson()">üì§ Datenbank exportieren</button>
                <button class="btn-admin btn-import">
                    üì• Datenbank laden
                    <input type="file" id="import-file-hidden" accept=".json" onchange="importJukeboxJson(this)">
                </button>
            </div>
            <button class="btn-admin btn-relink" id="btn-auto-repair" style="position:relative;">
                ü™Ñ Automatisch reparieren (Dateien verkn√ºpfen)
                <input type="file" id="repair-folder-input" webkitdirectory directory multiple onchange="smartRelinkFiles(this)">
            </button>
            <hr style="margin: 15px 0; border-top:1px solid #555;">
            <button class="btn-admin" style="background-color: #ff4757;" onclick="clearDatabase()">üóëÔ∏è Datenbank leeren</button>
        </div>

        <div class="footer-info">
            <p>Jukebox NFC V54</p>
            <p>Entwickelt von <b>Sebastian R√∂√üer</b></p>
            <p>üìß <a href="mailto:basecore@gmx.de">basecore@gmx.de</a></p>
            <p style="margin-top:10px;">
                <a href="https://github.com/basecore/jukebox/" target="_blank">üíª GitHub Projekt</a> &bull; 
                <a href="https://github.com/basecore/jukebox/issues" target="_blank">üêõ Fehler melden</a>
            </p>
        </div>
    </div>

    <div id="kids-mode">
        <button id="btn-open-lib" onclick="openLibrary()">
            <svg viewBox="0 0 24 24" style="width:60%; height:60%; fill:white;"><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9H9V9h10v2zm-4 4H9v-2h6v2zm4-8H9V5h10v2z"/></svg>
        </button>

        <div id="sleep-indicator">üåô <span id="sleep-countdown"></span></div>
        <div id="track-title-display" class="kids-text-shadow">Bereit zum Spielen!</div>
        <div id="playlist-info" class="kids-text-shadow"></div>
        
        <div id="album-art-container">
            <span id="album-placeholder">üéµ</span>
            <img id="album-img" src="" alt="Cover">
        </div>
        
        <div class="controls-main">
            <button id="btn-vol-down" class="btn-control btn-secondary" onclick="changeVolume(-0.1)">
                <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
            </button>
            <button id="btn-play-main" class="btn-control btn-play" onclick="togglePlay()">
                <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
            </button>
            <button id="btn-vol-up" class="btn-control btn-secondary" onclick="changeVolume(0.1)">
                <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
            </button>
        </div>

        <div id="volume-display-container">
            <div id="volume-bar"></div>
        </div>

        <div class="controls-nav-row">
             <button id="btn-reset" class="btn-control btn-secondary" onclick="restartPlaylist()" title="Reset">
                 <svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>
             </button>
             <button id="btn-skip" class="btn-control btn-secondary" onclick="skipForward()" title="Skip">
                 <svg viewBox="0 0 24 24"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg>
             </button>
             <button id="btn-next-track" class="btn-control btn-secondary" style="display:none;" onclick="skipToNextCueTrack()" title="Next Chapter">
                 <svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
             </button>
        </div>

        <div id="time-container" onclick="toggleTimeDisplayMode()">
            <div id="time-progress"></div>
            <div id="time-text">--:--</div>
        </div>
    </div>

    <div id="library-mode">
        <div class="lib-header">
            <div class="lib-title">Meine Sammlung üìö</div>
        </div>

        <div class="filter-scroll-container" id="lib-filters">
            <div class="filter-chip active" onclick="applyLibFilter('all', this)">Alle</div>
            <div class="filter-chip" onclick="applyLibFilter('recent', this)">Zuletzt geh√∂rt</div>
            </div>

        <div id="lib-content-area">
            </div>

        <button id="btn-close-lib" onclick="closeLibrary()">Zur√ºck zum Player</button>
    </div>

    <div id="lib-info-modal" onclick="closeAlbumInfo()">
        <div class="info-modal-content" onclick="event.stopPropagation()">
            <img id="info-modal-img" class="info-modal-cover" src="">
            <div id="info-modal-title" class="info-modal-h">Titel</div>
            <div id="info-modal-meta" class="info-modal-meta">Info</div>
            <div id="info-modal-desc" class="info-modal-desc">Beschreibung...</div>
            <button class="btn-close-modal" onclick="closeAlbumInfo()">Schlie√üen</button>
        </div>
    </div>

    <div id="status-msg"></div>
    <audio id="audio-player"></audio>

    <script>
        let db; let isParentMode = true; let ndef; let clickCount = 0; 
        const audioPlayer = document.getElementById('audio-player');
        
        let wakeLock = null;
        
        // --- HELFER: Safe Element Access ---
        function safeDisplay(id, val) {
            const el = document.getElementById(id);
            if(el) el.style.display = val;
        }
        function safeStyle(id, prop, val) {
            const el = document.getElementById(id);
            if(el) el.style[prop] = val;
        }

        const stubbornVideo = document.getElementById('stubborn-video');
        stubbornVideo.src = "data:video/mp4;base64,AAAAHGZ0eXBNNEVAAAAAAAEAAQAAAAAAAAAAAAAA1W1vb3YAAABsbXZoAAAAAQAAAAAA5G0AAORtAAABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAGGlvZHMAAAAAEICAgAcAT////3//AAACQXRyYWsAAABcdGtoZAAAAAEAAAAAAAAAAAAAAQAAAAEAAAAAAORtAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAADkbQAAAAABAAAAAAABM21kaWEAAAAgbWRoZAAAAAEAAAAAAORtAADkbQAAQBAAABExAAAAAAAAAAA5aGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAABAAAADG1pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAKFzdGJsAAAAp3N0ZHNkAAAAAAAAAAEAAABnYXZjMQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAEAAABIAAAASAAAAAAADqAAAAAAAP//AAAALWF2Y0MBAAAALgEASAAAAAb/gAQACAAAAAAhAAACigAAlzYBAAAAAwEBAAAAAwEBAAAAAGhzdHRzAAAAAAAAAAEAAAABAAABAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAwc3RzegAAAAAAAAAAAAAAAQAAABRzdGNvAAAAAAAAAAEAAACwAAAAYXVkdGEAAAAUY29wcmQAAAAAQmFzZWNvcmU=";
        
        stubbornVideo.addEventListener('pause', () => {
            if (settings.enableWakeLock && !isParentMode && !audioPlayer.paused) {
                stubbornVideo.play().catch(() => {});
            }
        });

        let currentKidsVolumePct = 1.0; 
        let settings = { maxVolume: 1.0, sleepTimerMinutes: 0, colorfulControls: false, startMode: 'parent', bgMode: 'default', bgColor: '#ffffff', enableWakeLock: false, enableEcoMode: false, enableLibrary: true };
        let sleepTimerId = null; let showRemainingTime = true; 
        let currentPlayingTagId = null; let currentTrackIndex = 0; let currentPlaylist = []; 
        let isNfcScanning = false; let isLinkModeActive = false;

        let currentCueTracks = null; 
        let editingOriginalTagId = null;

        const SYSTEM_BG_ID = "system_bg";
        const SYSTEM_SETTINGS_ID = "system_settings"; 

        if (!("NDEFReader" in window)) safeDisplay('nfc-warning', 'block');

        loadSettings(); 

        const DB_NAME = "MusicBoxDB_v15";
        const request = indexedDB.open(DB_NAME, 1);

        request.onupgradeneeded = function(event) {
            db = event.target.result;
            if (db.objectStoreNames.contains("tracks")) db.deleteObjectStore("tracks");
            db.createObjectStore("tracks", { keyPath: "tagId" });
        };

        request.onsuccess = function(event) { 
             db = event.target.result; 
             loadTagList();
             syncSettingsFromDB(); 
        };

        // --- BACKGROUND & DESIGN LOGIC ---
        function updateBgUIState() {
            const mode = document.getElementById('bg-mode-select').value;
            safeDisplay('bg-color-container', 'none');
            safeDisplay('bg-image-container', 'none');
            if (mode === 'color') safeDisplay('bg-color-container', 'block');
            else if (mode === 'image') safeDisplay('bg-image-container', 'block');
        }

        function saveBackgroundImage(input) {
            const file = input.files[0]; if(!file) return;
            const tx = db.transaction(["tracks"], "readwrite"); const store = tx.objectStore("tracks");
            store.put({tagId: SYSTEM_BG_ID, name: "System Background", imageBlob: file});
            tx.oncomplete = () => { showStatus("Hintergrund gespeichert üñºÔ∏è"); input.value = ""; applyKidsDesign(); };
        }

        function deleteBackgroundImage() {
            const tx = db.transaction(["tracks"], "readwrite"); const store = tx.objectStore("tracks");
            store.delete(SYSTEM_BG_ID);
            tx.oncomplete = () => { showStatus("Eigenes Bild gel√∂scht"); applyKidsDesign(); };
        }

        function applyKidsDesign() {
            try {
                const kidsDiv = document.getElementById('kids-mode');
                const mode = settings.bgMode || 'default';
                kidsDiv.style.backgroundImage = ''; 
                kidsDiv.style.backgroundColor = '';
                
                if (mode === 'default') { 
                    kidsDiv.style.backgroundImage = "url('assets/img/hintergrund.jpg')"; 
                    kidsDiv.style.backgroundColor = "#2c3e50"; // Fallback Dark Blue
                } 
                else if (mode === 'color') { kidsDiv.style.backgroundColor = settings.bgColor || '#ffffff'; }
                else if (mode === 'image') { 
                    if(!db) { kidsDiv.style.backgroundImage = "url('assets/img/hintergrund.jpg')"; return; }
                    const store = db.transaction(["tracks"], "readonly").objectStore("tracks");
                    const req = store.get(SYSTEM_BG_ID);
                    req.onsuccess = () => {
                        if(req.result && req.result.imageBlob) { const url = URL.createObjectURL(req.result.imageBlob); kidsDiv.style.backgroundImage = `url('${url}')`; } 
                        else { kidsDiv.style.backgroundImage = "url('assets/img/hintergrund.jpg')"; }
                    };
                }
            } catch(e) { console.log("Design Error", e); }
        }

        function syncSettingsFromDB() {
            const store = db.transaction(["tracks"], "readonly").objectStore("tracks");
            const req = store.get(SYSTEM_SETTINGS_ID);
            req.onsuccess = () => {
                if(req.result && req.result.data) {
                    settings = req.result.data; updateUIFromSettings();
                    if (settings.startMode === 'kids') { setTimeout(() => { goToKidsMode(); }, 100); }
                } else { saveSettings(); }
            };
        }

        function updateUIFromSettings() {
            document.getElementById('max-vol-input').value = settings.maxVolume * 100; 
            document.getElementById('vol-display').innerText = Math.round(settings.maxVolume * 100) + "%"; 
            document.getElementById('sleep-timer-input').value = settings.sleepTimerMinutes;
            document.getElementById('check-colorful').checked = settings.colorfulControls;
            document.getElementById('start-mode-input').value = settings.startMode || 'parent';
            document.getElementById('bg-mode-select').value = settings.bgMode || 'default';
            document.getElementById('bg-color-input').value = settings.bgColor || '#ffffff';
            document.getElementById('check-wakelock').checked = settings.enableWakeLock || false;
            document.getElementById('check-ecomode').checked = settings.enableEcoMode || false;
            document.getElementById('check-enable-lib').checked = settings.enableLibrary !== false; // Default true
            updateBgUIState(); 
        }

        function saveSettings() {
            settings.maxVolume = document.getElementById('max-vol-input').value / 100;
            applyActualVolume(); 
            settings.sleepTimerMinutes = parseInt(document.getElementById('sleep-timer-input').value);
            settings.colorfulControls = document.getElementById('check-colorful').checked;
            settings.startMode = document.getElementById('start-mode-input').value;
            settings.bgMode = document.getElementById('bg-mode-select').value;
            settings.bgColor = document.getElementById('bg-color-input').value;
            settings.enableWakeLock = document.getElementById('check-wakelock').checked;
            settings.enableEcoMode = document.getElementById('check-ecomode').checked;
            settings.enableLibrary = document.getElementById('check-enable-lib').checked;
            localStorage.setItem('jukeboxSettings_v15', JSON.stringify(settings));
            if(db) { const tx = db.transaction(["tracks"], "readwrite"); tx.objectStore("tracks").put({ tagId: SYSTEM_SETTINGS_ID, name: "System Settings", data: settings }); }
        }

        function loadSettings() {
            const saved = localStorage.getItem('jukeboxSettings_v15');
            if (saved) { settings = JSON.parse(saved); updateUIFromSettings(); if (settings.startMode === 'kids') { setTimeout(() => { goToKidsMode(); }, 100); } }
        }

        function updateSettingsUI() { const vol = document.getElementById('max-vol-input').value; document.getElementById('vol-display').innerText = vol + "%"; saveSettings(); }

        function applyActualVolume() { let visualVolume = currentKidsVolumePct * settings.maxVolume; audioPlayer.volume = Math.pow(visualVolume, 2); }
        function changeVolume(change) { currentKidsVolumePct += change; if(currentKidsVolumePct > 1.0) currentKidsVolumePct = 1.0; if(currentKidsVolumePct < 0.0) currentKidsVolumePct = 0.0; applyActualVolume(); updateVolumeUI(); }
        function updateVolumeUI() {
            let pct = currentKidsVolumePct * 100; const bar = document.getElementById('volume-bar'); bar.style.width = pct + "%";
            if(pct < 40) bar.style.backgroundColor = "var(--green-safe)"; else if (pct < 75) bar.style.backgroundColor = "var(--orange-warn)"; else bar.style.backgroundColor = "var(--red-danger)";
        }

        function playTestTone() {
            const testAudio = new Audio('assets/limit.mp3');
            testAudio.volume = Math.pow(settings.maxVolume, 2);
            showStatus("üîä Spiele Test-Datei...");
            testAudio.play().catch(e => { console.log("Fehler:", e); showStatus("Fehler: limit.mp3 fehlt?"); });
        }

        // --- WAKE LOCK & ECO (SAFE) ---
        async function requestWakeLock() {
            if (!settings.enableWakeLock) return;
            if ('wakeLock' in navigator) { 
                try { wakeLock = await navigator.wakeLock.request('screen'); } 
                catch (err) { console.error("WakeLock failed:", err); } 
            }
            if(stubbornVideo) stubbornVideo.play().catch(e => {});
        }
        
        async function releaseWakeLock() { 
            if (wakeLock !== null) { await wakeLock.release(); wakeLock = null; } 
            if(stubbornVideo) stubbornVideo.pause(); 
        }
        
        document.addEventListener('visibilitychange', async () => { 
            if (document.visibilityState === 'visible' && settings.enableWakeLock && !isParentMode) { 
                requestWakeLock(); 
            } 
        });

        document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'hidden') { forceSaveCurrentPosition(); } });
        window.addEventListener('beforeunload', () => { forceSaveCurrentPosition(); });

        function updateEcoModeState(fromCheckbox = false) {
            const isChecked = document.getElementById('check-ecomode').checked;
            const curtain = document.getElementById('black-curtain');
            if (isChecked) { 
                window.addEventListener('deviceorientation', handleOrientation); 
                if(fromCheckbox) showStatus("Sensoren gestartet ‚úÖ"); 
            } else { 
                window.removeEventListener('deviceorientation', handleOrientation); 
                if(curtain) curtain.style.display = 'none'; 
                if(fromCheckbox) showStatus("Sensoren aus"); 
            }
            if(fromCheckbox) saveSettings();
        }
        
        function handleOrientation(event) {
            const beta = event.beta; if(beta === null) return; const isFaceDown = (beta > 140 || beta < -140);
            const curtain = document.getElementById('black-curtain');
            if(!curtain) return;
            if (isFaceDown) { if (curtain.style.display !== 'block') curtain.style.display = 'block'; } 
            else { if (curtain.style.display === 'block') curtain.style.display = 'none'; }
        }
        
        function requestIOSPermission() {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(response => {
                    if (response === 'granted') { alert("Sensoren aktiviert! ‚úÖ"); document.getElementById('check-ecomode').checked = true; updateEcoModeState(true); } else { alert("Zugriff verweigert ‚ùå"); }
                }).catch(console.error);
            } else { alert("Auf diesem Ger√§t nicht n√∂tig/m√∂glich."); }
        }

        // --- DB EXPORT/IMPORT ---
        async function exportJukeboxJson() {
            showStatus("Exportiere...");
            const tx = db.transaction(["tracks"], "readonly");
            const store = tx.objectStore("tracks");
            const exportData = [];

            store.openCursor().onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    const t = cursor.value;
                    if(t.tagId !== SYSTEM_BG_ID && t.tagId !== SYSTEM_SETTINGS_ID) {
                        exportData.push({
                            tagId: t.tagId,
                            name: t.name,
                            playlistFileNames: t.playlistFileNames || [],
                            imageFileName: t.imageFileName || null,
                            meta: t.meta || {},
                            tags: t.tags || [],
                            filter_age: t.filter_age || 0
                        });
                    }
                    cursor.continue();
                } else {
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: "application/json"});
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = "jukebox.json";
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    showStatus("Export fertig! ‚úÖ");
                }
            };
        }

        async function importJukeboxJson(input) {
            const file = input.files[0]; if(!file) return;
            showStatus("Lade Datenbank...");
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if(!Array.isArray(data)) throw new Error("Format falsch");

                    const tx = db.transaction(["tracks"], "readwrite");
                    const store = tx.objectStore("tracks");
                    let updated = 0; let newEntries = 0;

                    for(const entry of data) {
                        await new Promise((resolve) => {
                            const req = store.get(entry.tagId);
                            req.onsuccess = () => {
                                const existing = req.result;
                                if(existing) {
                                    existing.name = entry.name;
                                    existing.meta = entry.meta;
                                    existing.tags = entry.tags;
                                    existing.filter_age = entry.filter_age;
                                    store.put(existing);
                                    updated++;
                                } else {
                                    store.put({
                                        tagId: entry.tagId,
                                        name: entry.name,
                                        playlist: [], 
                                        playlistFileNames: entry.playlistFileNames,
                                        imageBlob: null,
                                        imageFileName: entry.imageFileName,
                                        cueTracks: null,
                                        meta: entry.meta,
                                        tags: entry.tags,
                                        lastTrackIndex:0, lastTime:0
                                    });
                                    newEntries++;
                                }
                                resolve();
                            };
                        });
                    }
                    
                    alert(`Datenbank geladen!\n\n‚Ä¢ ${updated} Eintr√§ge aktualisiert\n‚Ä¢ ${newEntries} neue Eintr√§ge erstellt.\n\nWICHTIG: Die Audio-Dateien fehlen noch.\nBitte klicke jetzt auf 'Automatisch reparieren' und w√§hle den Ordner mit deinen MP3s aus!`);
                    
                    const btn = document.getElementById('btn-auto-repair');
                    if(btn) {
                        btn.style.backgroundColor = "#e74c3c"; 
                        btn.style.animation = "pulse 2s infinite";
                    }

                    loadTagList();
                    input.value = "";
                } catch(e) { alert("Fehler: " + e); }
            };
            reader.readAsText(file);
        }

        // --- BULK IMPORT (V49 SMART FIX) ---
        async function handleBulkImport(input) {
            const files = Array.from(input.files);
            if(files.length === 0) return;
            
            showStatus(`Pr√ºfe ${files.length} Dateien...`);
            
            const jukeboxJsonFile = files.find(f => f.name.toLowerCase().startsWith('jukebox') && f.name.toLowerCase().endsWith('.json'));
            
            if (jukeboxJsonFile) {
                const usedAudioFiles = await handleJukeboxJsonImport(jukeboxJsonFile, files);
                const audioExtensions = ['.mp3', '.m4a', '.ogg', '.wav', '.flac'];
                const leftoverAudio = files.filter(f => {
                    const ext = f.name.substring(f.name.lastIndexOf('.')).toLowerCase();
                    return audioExtensions.includes(ext) && !usedAudioFiles.has(f.name);
                });

                if (leftoverAudio.length > 0) {
                    if(confirm(`Smart Import fertig. Es wurden noch ${leftoverAudio.length} weitere Audio-Dateien gefunden, die nicht in der JSON stehen.\n\nSollen diese auch importiert werden (via Dateiname)?`)) {
                        const filesForClassic = files.filter(f => !usedAudioFiles.has(f.name));
                        await handleClassicBulkImport(filesForClassic);
                    }
                }
            } else {
                await handleClassicBulkImport(files);
            }
            input.value = ""; 
        }

        async function handleJukeboxJsonImport(jsonFile, allFiles) {
            showStatus("Lade " + jsonFile.name + "...");
            const readFileAsText = (file) => new Promise((res, rej) => {
                const r = new FileReader(); r.onload = e => res(e.target.result); r.onerror = rej; r.readAsText(file);
            });

            const usedAudioSet = new Set();

            try {
                const jsonText = await readFileAsText(jsonFile);
                const metadataEntries = JSON.parse(jsonText);
                let count = 0;
                
                const findFile = (name) => allFiles.find(f => f.name === name);

                for (let i = 0; i < metadataEntries.length; i++) {
                    const entry = metadataEntries[i];
                    showStatus(`Smart Import ${i+1}/${metadataEntries.length}: ${entry.name}`);

                    const audioFiles = [];
                    if (entry.playlistFileNames) {
                        for (const fname of entry.playlistFileNames) {
                            const f = findFile(fname);
                            if (f) {
                                audioFiles.push(f);
                                usedAudioSet.add(f.name); 
                            }
                        }
                    }

                    if (audioFiles.length === 0) continue;

                    let imageBlob = null;
                    if (entry.imageFileName) imageBlob = findFile(entry.imageFileName);

                    let cueTracks = null;
                    if(entry.playlistFileNames.length > 0) {
                        const audioBase = entry.playlistFileNames[0].replace(/\.[^/.]+$/, "");
                        const cueFile = findFile(audioBase + ".cue");
                        if (cueFile) {
                            try {
                                const cueText = await readFileAsText(cueFile);
                                cueTracks = parseCueSheet(cueText);
                            } catch(e) {}
                        }
                    }

                    await new Promise((resolve, reject) => {
                        const tx = db.transaction(["tracks"], "readwrite");
                        const store = tx.objectStore("tracks");
                        
                        const record = {
                            tagId: entry.tagId,
                            name: entry.name,
                            playlist: audioFiles,
                            playlistFileNames: entry.playlistFileNames,
                            imageBlob: imageBlob,
                            imageFileName: entry.imageFileName,
                            cueTracks: cueTracks,
                            meta: entry.meta, 
                            tags: entry.tags,
                            lastTrackIndex: 0, lastTime: 0
                        };
                        
                        store.put(record);
                        tx.oncomplete = () => { count++; resolve(); };
                        tx.onerror = (e) => { 
                            if(e.target.error.name === "QuotaExceededError") {
                                alert("SPEICHER VOLL!"); reject("Quota");
                            } else resolve(); 
                        };
                    });
                }
                showStatus(`${count} Smart-Import fertig!`);
                loadTagList();
                return usedAudioSet;

            } catch (e) {
                console.error(e);
                alert("Fehler beim Lesen der JSON: " + e);
                return usedAudioSet;
            }
        }

        async function handleClassicBulkImport(files) {
            const groups = {};
            files.forEach(f => {
                const path = f.webkitRelativePath || f.name;
                const lastDot = path.lastIndexOf('.');
                const basePath = lastDot > 0 ? path.substring(0, lastDot) : path;
                
                if (!groups[basePath]) groups[basePath] = { audio: [], img: null, cue: null, name: "" };
                
                const ext = f.name.split('.').pop().toLowerCase();
                const fileNameOnly = f.name.substring(0, f.name.lastIndexOf('.'));
                if (!groups[basePath].name) groups[basePath].name = fileNameOnly;

                if(['mp3', 'm4a', 'ogg', 'wav', 'flac'].includes(ext)) { groups[basePath].audio.push(f); } 
                else if (['jpg', 'jpeg', 'png', 'webp'].includes(ext)) { groups[basePath].img = f; } 
                else if (ext === 'cue') { groups[basePath].cue = f; }
            });

            let count = 0;
            const groupKeys = Object.keys(groups);
            const totalGroups = groupKeys.length;

            const readFileAsText = (file) => new Promise((res, rej) => {
                const r = new FileReader(); r.onload = e => res(e.target.result); r.onerror = rej; r.readAsText(file);
            });

            for (let i = 0; i < totalGroups; i++) {
                const key = groupKeys[i];
                const g = groups[key];
                
                if(g.audio.length === 0) continue;

                const statusEl = document.getElementById('status-msg');
                statusEl.innerText = `Classic Import ${i+1}/${totalGroups}: ${g.name}`;
                statusEl.style.display = 'block';

                let cueTracks = null;
                if(g.cue) {
                    try { const text = await readFileAsText(g.cue); cueTracks = parseCueSheet(text); } catch(e) {}
                }

                try {
                    await new Promise((resolve, reject) => {
                        const tx = db.transaction(["tracks"], "readwrite");
                        const store = tx.objectStore("tracks");
                        
                        const fileNames = g.audio.map(f => f.name);
                        const tagId = "manual_" + Date.now() + "_" + Math.random().toString(36).substr(2, 5);
                        
                        const record = {
                            tagId: tagId,
                            name: g.name.replace(/_/g, ' '),
                            playlist: g.audio,
                            playlistFileNames: fileNames,
                            imageBlob: g.img,
                            imageFileName: g.img ? g.img.name : null,
                            cueTracks: cueTracks,
                            lastTrackIndex: 0, lastTime: 0
                        };
                        
                        store.put(record);
                        tx.oncomplete = () => { count++; resolve(); };
                        tx.onerror = (e) => { 
                            if(e.target.error.name === "QuotaExceededError") { alert("SPEICHER VOLL!"); reject("QuotaExceeded"); } 
                            else resolve(); 
                        };
                    });
                } catch(err) { if(err === "QuotaExceeded") break; }
            }
            showStatus(`${count} Importiert! üéâ`);
            loadTagList();
        }

        // --- NFC LOGIC ---
        async function startNFC() {
            if (isNfcScanning) return; if ("NDEFReader" in window) {
                try {
                    ndef = new NDEFReader(); await ndef.scan(); isNfcScanning = true; showStatus("Scanner gestartet ‚úÖ");
                    ndef.onreading = event => {
                        const flash = document.getElementById('flash-overlay'); flash.style.opacity = "1"; setTimeout(() => flash.style.opacity = "0", 200);
                        if (isParentMode) {
                            if (isLinkModeActive) { saveTrackLink(event.serialNumber); isLinkModeActive = false; } else { showStatus("Tag erkannt: " + event.serialNumber); }
                        } else { playTrackByTag(event.serialNumber); }
                    };
                } catch (error) { console.log("NFC Fehler:", error); isNfcScanning=false; }
            }
        }

        function activateLinkMode() {
            const n = document.getElementById('track-name').value;
            const hasAudio = document.getElementById('audio-input').files.length > 0;
            if(!editingOriginalTagId && !hasAudio) { alert("Bitte Audio w√§hlen!"); return; }
            if(n === "") { alert("Bitte Name eingeben!"); return; }
            isLinkModeActive = true; document.getElementById('scan-status').innerText = ">>> FIGUR JETZT AUFLEGEN <<<";
            if (!isNfcScanning) startNFC();
        }

        // --- MANUELLES SPEICHERN ---
        function saveManualTrack() {
            const n = document.getElementById('track-name').value;
            const hasAudio = document.getElementById('audio-input').files.length > 0;
            if(!editingOriginalTagId && !hasAudio) { alert("Bitte Audio w√§hlen!"); return; }
            if(n === "") { alert("Bitte Name eingeben!"); return; }
            const targetId = editingOriginalTagId ? editingOriginalTagId : "manual_" + Date.now();
            saveTrackLink(targetId);
        }

        // --- EDITING LOGIC ---
        function loadTagForEdit(id) {
            const store = db.transaction(["tracks"], "readonly").objectStore("tracks");
            store.get(id).onsuccess = (e) => {
                const r = e.target.result;
                if(r) {
                    editingOriginalTagId = id;
                    document.getElementById('track-name').value = r.name;
                    document.getElementById('form-title').innerText = "‚úèÔ∏è Tag bearbeiten (ID: " + id + ")";
                    document.getElementById('btn-save-tag').innerText = "Speichern & Scannen (Tag wechseln)";
                    document.getElementById('btn-save-manual').innerText = "üíæ Nur Speichern (Update)";
                    document.getElementById('btn-cancel-edit').style.display = "inline-block";
                    
                    document.getElementById('audio-info').innerText = "Aktuell: " + (r.playlistFileNames ? r.playlistFileNames.length + " Dateien" : "Vorhanden");
                    document.getElementById('cue-info').innerText = r.cueTracks ? "Aktuell: Cue vorhanden" : "Aktuell: Keine";
                    document.getElementById('img-info').innerText = r.imageFileName ? "Aktuell: " + r.imageFileName : "Aktuell: Standard";
                    
                    document.getElementById('scan-card').classList.add("editing-highlight");
                    document.getElementById('parent-mode').scrollTop = 0;
                }
            };
        }

        function cancelEdit() {
            editingOriginalTagId = null;
            document.getElementById('track-name').value = "";
            document.getElementById('audio-input').value = "";
            document.getElementById('cue-input').value = "";
            document.getElementById('img-input').value = "";
            document.getElementById('audio-info').innerText = "";
            document.getElementById('cue-info').innerText = "";
            document.getElementById('img-info').innerText = "";
            document.getElementById('form-title').innerText = "üéµ Neuen Tag anlernen";
            document.getElementById('btn-save-tag').innerText = "üì° Tag scannen & speichern";
            document.getElementById('btn-save-manual').innerText = "üíæ Ohne NFC speichern (f√ºr sp√§ter)";
            document.getElementById('btn-cancel-edit').style.display = "none";
            document.getElementById('scan-card').classList.remove("editing-highlight");
            document.getElementById('scan-status').innerText = "";
        }

        function parseCueSheet(cueText) {
            const tracks = []; const lines = cueText.split('\n'); let currentTrack = null;
            lines.forEach(line => {
                line = line.trim();
                if (line.startsWith('TRACK')) { currentTrack = {}; }
                if (line.startsWith('TITLE') && currentTrack) { const match = line.match(/"([^"]+)"/); if (match) currentTrack.title = match[1]; }
                if (line.startsWith('INDEX 01') && currentTrack) {
                    const parts = line.split(' '); const timeStr = parts[parts.length - 1]; const timeParts = timeStr.split(':');
                    const min = parseInt(timeParts[0], 10); const sec = parseInt(timeParts[1], 10); const frames = parseInt(timeParts[2], 10);
                    const totalSeconds = (min * 60) + sec + (frames / 75);
                    currentTrack.time = totalSeconds; tracks.push(currentTrack); currentTrack = null;
                }
            }); return tracks;
        }

        // --- PLAYBACK (UPDATED: RECORD PLAY TIMESTAMP) ---
        function playTrackByTag(tagId) {
            if(currentPlayingTagId && currentPlayingTagId !== tagId) forceSaveCurrentPosition();
            
            // WICHTIG: Transaktion muss jetzt "readwrite" sein, damit wir den Timestamp speichern k√∂nnen
            const tx = db.transaction(["tracks"], "readwrite");
            const store = tx.objectStore("tracks");
            
            store.get(tagId).onsuccess = (e) => {
                const track = e.target.result;
                if(track) {
                    // --- NEU: Zeitstempel f√ºr "Zuletzt geh√∂rt" speichern ---
                    track.lastPlayedTimestamp = Date.now();
                    store.put(track);
                    // -----------------------------------------------------

                    if(!track.playlist || track.playlist.length === 0) { showStatus("‚ö†Ô∏è Audio fehlt!"); return; }
                    document.getElementById('track-title-display').innerText = track.name;
                    const imgEl = document.getElementById('album-img'); const placeEl = document.getElementById('album-placeholder');
                    if(track.imageBlob) { imgEl.src = URL.createObjectURL(track.imageBlob); imgEl.style.display="block"; placeEl.style.display="none"; } 
                    else { imgEl.style.display="none"; placeEl.style.display="block"; }
                    
                    currentPlayingTagId = tagId; currentPlaylist = track.playlist;
                    currentCueTracks = track.cueTracks || null;
                    const nextBtn = document.getElementById('btn-next-track');
                    if(currentCueTracks && currentCueTracks.length > 0) { nextBtn.style.display = "flex"; } else { nextBtn.style.display = "none"; }

                    let startIndex = track.lastTrackIndex || 0; let startTime = track.lastTime || 0;
                    if(startIndex >= currentPlaylist.length) startIndex = 0;
                    
                    playPlaylistIndex(startIndex, startTime);
                    if (isParentMode) { goToKidsMode(); }
                } else { showStatus("Tag unbekannt"); }
            };
        }

        function playPlaylistIndex(index, startTime = 0) {
            if(index >= currentPlaylist.length) return;
            currentTrackIndex = index;
            const file = currentPlaylist[index];
            const audioUrl = URL.createObjectURL(file);
            updateInfoText();
            audioPlayer.src = audioUrl;
            audioPlayer.onloadedmetadata = () => {
                if(startTime > 0 && startTime < audioPlayer.duration - 2) audioPlayer.currentTime = startTime;
                applyActualVolume(); updateVolumeUI();
                audioPlayer.play().then(() => { setPlayButtonState(true); startSleepTimer(); requestWakeLock(); }).catch(e => showStatus("Bereit"));
                audioPlayer.onloadedmetadata = null;
            };
        }

        function updateInfoText() {
            const infoEl = document.getElementById('playlist-info');
            if (currentCueTracks) { infoEl.innerText = "Kapitel laden..."; } 
            else {
                if(currentPlaylist.length > 1) infoEl.innerText = `Teil ${currentTrackIndex+1} von ${currentPlaylist.length}`;
                else infoEl.innerText = "";
            }
        }

        function skipToNextCueTrack() {
            if(!currentCueTracks || !audioPlayer.src) return;
            const now = audioPlayer.currentTime;
            const nextTrack = currentCueTracks.find(t => t.time > (now + 2)); 
            if(nextTrack) { audioPlayer.currentTime = nextTrack.time; showStatus("‚è© " + nextTrack.title); } else { showStatus("Ende erreicht"); }
        }

        audioPlayer.onended = () => {
            if(currentPlayingTagId && currentPlaylist.length > 0) {
                if(currentTrackIndex + 1 < currentPlaylist.length) playPlaylistIndex(currentTrackIndex + 1, 0);
                else { setPlayButtonState(false); currentTrackIndex = 0; forceSaveCurrentPosition(); releaseWakeLock(); }
            }
        };

        async function smartRelinkFiles(input) {
            const files = Array.from(input.files); if(files.length === 0) return;
            showStatus(`Pr√ºfe ${files.length} Dateien...`);
            const tx = db.transaction(["tracks"], "readwrite"); const store = tx.objectStore("tracks"); let fixedCount = 0;
            store.getAll().onsuccess = (e) => {
                e.target.result.forEach(record => {
                    if(record.tagId === SYSTEM_BG_ID || record.tagId === SYSTEM_SETTINGS_ID) return;
                    let changed = false;
                    if (record.playlistFileNames && (!record.playlist || record.playlist.length === 0)) {
                        const newPlaylist = []; record.playlistFileNames.forEach(name => { const f = files.find(x => x.name === name); if(f) newPlaylist.push(f); });
                        if(newPlaylist.length > 0) { record.playlist = newPlaylist; changed = true; }
                    }
                    if (record.imageFileName && !record.imageBlob) { const img = files.find(x => x.name === record.imageFileName); if(img) { record.imageBlob = img; changed = true; } }
                    if(changed) { store.put(record); fixedCount++; }
                });
            }; tx.oncomplete = () => { showStatus(`${fixedCount} repariert! üéâ`); loadTagList(); input.value = ""; };
        }

        function togglePlay() { 
            if (audioPlayer.paused) { 
                if(audioPlayer.src) { audioPlayer.play(); setPlayButtonState(true); startSleepTimer(); requestWakeLock(); } 
                else { showStatus("Tag?"); } 
            } else { 
                audioPlayer.pause(); setPlayButtonState(false); stopSleepTimer(); releaseWakeLock(); forceSaveCurrentPosition();
            } 
        }
        function restartPlaylist() { if(currentPlayingTagId) { showStatus("Start..."); playPlaylistIndex(0, 0); } }
        function skipForward() { if(audioPlayer.src) { audioPlayer.currentTime += 30; showStatus("+30 Sek"); } }

        function setPlayButtonState(isPlaying) {
            const btn = document.getElementById('btn-play-main');
            if (isPlaying) { btn.style.backgroundColor = "var(--red-danger)"; btn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>'; } 
            else { btn.style.backgroundColor = "var(--green-safe)"; btn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>'; }
        }

        function forceSaveCurrentPosition() {
            if(!currentPlayingTagId) return;
            const pos = audioPlayer.currentTime; const tx = db.transaction(["tracks"], "readwrite"); const store = tx.objectStore("tracks"); const getReq = store.get(currentPlayingTagId);
            getReq.onsuccess = function() { const record = getReq.result; if(record) { record.lastTrackIndex = currentTrackIndex; record.lastTime = pos; store.put(record); } };
        }

        function startSleepTimer() {
            if(sleepTimerId) clearTimeout(sleepTimerId); document.getElementById('sleep-indicator').style.display = 'none';
            if(settings.sleepTimerMinutes > 0 && !audioPlayer.paused) {
                document.getElementById('sleep-indicator').style.display = 'block'; document.getElementById('sleep-countdown').innerText = settings.sleepTimerMinutes + " min";
                sleepTimerId = setTimeout(() => { fadeOutAndStop(); }, settings.sleepTimerMinutes * 60 * 1000);
            }
        }
        function stopSleepTimer() { if(sleepTimerId) clearTimeout(sleepTimerId); document.getElementById('sleep-indicator').style.display = 'none'; }
        function fadeOutAndStop() { let vol = audioPlayer.volume; const fade = setInterval(() => { if(vol > 0.05) { vol -= 0.05; audioPlayer.volume = vol; } else { clearInterval(fade); audioPlayer.pause(); setPlayButtonState(false); forceSaveCurrentPosition(); applyActualVolume(); showStatus("Gute Nacht üò¥"); } }, 200); }
        function clearDatabase() { if(confirm("L√∂schen?")) { db.close(); indexedDB.deleteDatabase(DB_NAME); location.reload(); } }
        function showStatus(msg) { const el = document.getElementById('status-msg'); el.innerText = msg; el.style.display = 'block'; setTimeout(() => { el.style.display = 'none'; }, 3000); }
        function formatTime(s) { const minutes = Math.floor(s / 60); const seconds = Math.floor(s % 60); return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; }
        function applyButtonColors() {
            try {
                const volDown = document.getElementById('btn-vol-down'); const volUp = document.getElementById('btn-vol-up'); const back = document.getElementById('btn-reset'); const skip = document.getElementById('btn-skip'); const next = document.getElementById('btn-next-track');
                if (settings && settings.colorfulControls) { 
                    volDown.classList.add('btn-colorful-vol-down'); volUp.classList.add('btn-colorful-vol-up'); back.classList.add('btn-colorful-back'); skip.classList.add('btn-colorful-skip'); next.classList.add('btn-colorful-next');
                } else { 
                    volDown.classList.remove('btn-colorful-vol-down'); volUp.classList.remove('btn-colorful-vol-up'); back.classList.remove('btn-colorful-back'); skip.classList.remove('btn-colorful-skip'); next.classList.remove('btn-colorful-next');
                }
            } catch(e) {}
        }

        audioPlayer.addEventListener('timeupdate', () => {
            if(isNaN(audioPlayer.duration)) { document.getElementById('time-text').innerText = "--:--"; return; }
            const current = audioPlayer.currentTime; const total = audioPlayer.duration; const pct = (current/total)*100;
            document.getElementById('time-progress').style.width = pct + "%";
            document.getElementById('time-text').innerText = showRemainingTime ? "-" + formatTime(total-current) : formatTime(current);
            
            if(currentCueTracks) {
                let currentChapterName = "";
                for(let i=currentCueTracks.length-1; i>=0; i--) {
                    if(current >= currentCueTracks[i].time) { currentChapterName = currentCueTracks[i].title; break; }
                }
                if(currentChapterName) document.getElementById('playlist-info').innerText = currentChapterName;
            }
        });

        function toggleTimeDisplayMode() { showRemainingTime = !showRemainingTime; updateTimeDisplay(); }
        // Fallback: Global click listener startet NFC, falls Autostart fehlschl√§gt
        document.body.addEventListener('click', async () => { if(!ndef && "NDEFReader" in window) { try { await startNFC(); } catch(e) {} } }, { once: true });

        function goToKidsMode() {
            try {
                // UI Switch First
                safeDisplay('parent-mode', 'none');
                safeDisplay('kids-mode', 'flex'); 

                // Setup
                isParentMode = false;
                applyKidsDesign(); 
                applyButtonColors();

                // TOGGLE LIBRARY BUTTON BASED ON SETTINGS
                if(settings.enableLibrary !== false) {
                     document.getElementById('btn-open-lib').style.display = 'flex';
                } else {
                     document.getElementById('btn-open-lib').style.display = 'none';
                }

                if (document.documentElement.requestFullscreen) { document.documentElement.requestFullscreen().catch((e) => {}); }
                if(settings.enableEcoMode) updateEcoModeState(false);
                
                // WakeLock Start
                requestWakeLock();
                startNFC().catch(err => console.log("NFC Error", err));

            } catch(e) {
                alert("Fehler beim Starten: " + e);
                // NOTFALL R√úCKZUG
                safeDisplay('kids-mode', 'none');
                safeDisplay('parent-mode', 'flex');
            }
        }
        
        // Touch Listener f√ºr iOS / Mobile Wake Lock
        document.getElementById('kids-mode').addEventListener('touchstart', () => {
            if(!isParentMode) requestWakeLock();
        }, {passive: true});

        function handleSecretSwitch() {
            clickCount++; setTimeout(() => { clickCount = 0; }, 2000); 
            if (clickCount >= 5) {
                safeDisplay('kids-mode', 'none');
                safeDisplay('parent-mode', 'flex');
                isParentMode = true; clickCount = 0; releaseWakeLock(); 
                if (document.exitFullscreen && document.fullscreenElement) { document.exitFullscreen().catch((e) => {}); }
            }
        }
        function autoFillName() {
            const input = document.getElementById('audio-input'); const nameField = document.getElementById('track-name');
            if (input.files.length > 0 && nameField.value === "") {
                let name = input.files[0].name; if(name.lastIndexOf('.') > 0) { name = name.substring(0, name.lastIndexOf('.')); } nameField.value = name;
            }
        }

        // --- SPEICHERN (UPDATED MIT EDIT-LOGIC) ---
        function saveTrackLink(tagId) {
            const audioInput = document.getElementById('audio-input');
            const imgInput = document.getElementById('img-input');
            const cueInput = document.getElementById('cue-input');
            const name = document.getElementById('track-name').value;

            // Logik: Wir holen uns ggf. die alten Daten, wenn wir im Edit Mode sind
            const finalize = (oldRecord = null, newCueTracks = null) => {
                
                let finalAudio = audioInput.files.length > 0 ? Array.from(audioInput.files) : (oldRecord ? oldRecord.playlist : []);
                let finalFileNames = audioInput.files.length > 0 ? Array.from(audioInput.files).map(f=>f.name) : (oldRecord ? oldRecord.playlistFileNames : []);
                
                let finalImg = imgInput.files.length > 0 ? imgInput.files[0] : (oldRecord ? oldRecord.imageBlob : null);
                let finalImgName = imgInput.files.length > 0 ? imgInput.files[0].name : (oldRecord ? oldRecord.imageFileName : null);
                
                let finalCue = newCueTracks ? newCueTracks : (oldRecord ? oldRecord.cueTracks : null);

                if(finalAudio.length === 0) { alert("Kein Audio vorhanden!"); return; }

                const record = { 
                    tagId: tagId, 
                    name: name, 
                    playlist: finalAudio, 
                    playlistFileNames: finalFileNames, 
                    imageBlob: finalImg, 
                    imageFileName: finalImgName, 
                    cueTracks: finalCue, 
                    lastTrackIndex: oldRecord ? oldRecord.lastTrackIndex : 0, 
                    lastTime: oldRecord ? oldRecord.lastTime : 0 
                };

                const tx = db.transaction(["tracks"], "readwrite"); 
                const store = tx.objectStore("tracks");
                
                // Neuen Eintrag speichern
                store.put(record);

                // Wenn wir editiert haben und die Tag ID sich ge√§ndert hat (neuer Tag gescannt), alten l√∂schen
                if (editingOriginalTagId && editingOriginalTagId !== tagId) {
                    store.delete(editingOriginalTagId);
                    showStatus("Tag gewechselt & gespeichert!");
                } else {
                    showStatus("Gespeichert!");
                }

                tx.oncomplete = () => { cancelEdit(); loadTagList(); };
            };

            // Workflow Start
            const cueFile = cueInput.files[0];
            
            const processCueAndSave = (oldRecord) => {
                if(cueFile) {
                    const reader = new FileReader(); 
                    reader.onload = (e) => { const parsedTracks = parseCueSheet(e.target.result); finalize(oldRecord, parsedTracks); }; 
                    reader.readAsText(cueFile);
                } else {
                    finalize(oldRecord, null);
                }
            };

            if (editingOriginalTagId) {
                const store = db.transaction(["tracks"], "readonly").objectStore("tracks");
                store.get(editingOriginalTagId).onsuccess = (e) => { processCueAndSave(e.target.result); };
            } else {
                if(audioInput.files.length === 0) { alert("Bitte Audio w√§hlen!"); return; }
                processCueAndSave(null);
            }
        }

        function loadTagList() {
            const list = document.getElementById('tag-list'); if(!list) return; list.innerHTML = "";
            const tx = db.transaction(["tracks"], "readonly"); const store = tx.objectStore("tracks");
            store.openCursor().onsuccess = (event) => {
                const cursor = event.target.result; if (cursor) {
                    const track = cursor.value;
                    if(track.tagId !== SYSTEM_BG_ID && track.tagId !== SYSTEM_SETTINGS_ID) {
                        const div = document.createElement('div'); div.className = "tag-list-item";
                        div.innerHTML = `
                            <div class="tag-info-row">
                                <strong>${track.name}</strong>
                                <span style="font-size:0.8em; color:#aaa;">ID: ${track.tagId}</span>
                            </div>
                            <div class="tag-action-row">
                                <button class="btn-fix-audio btn-edit" onclick="loadTagForEdit('${track.tagId}')">‚úèÔ∏è Bearbeiten</button>
                                <button class="btn-fix-audio" onclick="playTrackByTag('${track.tagId}')">‚ñ∂ Testen</button>
                                <button class="btn-fix-audio" style="background:#ff7675; color:white;" onclick="deleteTrack('${track.tagId}')">L√∂schen</button>
                            </div>
                        `;
                        list.appendChild(div);
                    } cursor.continue();
                }
            };
        }
        function deleteTrack(id) { if(confirm("Wirklich l√∂schen?")) { const tx = db.transaction(["tracks"], "readwrite"); tx.objectStore("tracks").delete(id); tx.oncomplete = () => loadTagList(); } }

        // --- LIBRARY MODE LOGIC (NEU) ---

        let currentLibFilter = 'all';

        function openLibrary() {
            document.getElementById('library-mode').style.display = 'flex';
            renderLibrary();
        }

        function closeLibrary() {
            document.getElementById('library-mode').style.display = 'none';
        }

        function renderLibrary() {
            const contentArea = document.getElementById('lib-content-area');
            const filterContainer = document.getElementById('lib-filters');
            contentArea.innerHTML = "";
            
            // 1. Daten holen
            const tx = db.transaction(["tracks"], "readonly");
            const store = tx.objectStore("tracks");
            const request = store.getAll();

            request.onsuccess = (e) => {
                let tracks = e.target.result;
                
                // System-Dateien filtern
                tracks = tracks.filter(t => t.tagId !== "system_bg" && t.tagId !== "system_settings");

                // --- FILTER GENERIEREN (Dynamisch) ---
                // Wir bauen die Filter nur einmal oder resetten sie
                if(filterContainer.children.length <= 2) { 
                    // Nur generieren wenn noch nicht da (Standard: Alle, Zuletzt)
                    const genres = new Set();
                    const ages = new Set();
                    
                    tracks.forEach(t => {
                        if(t.meta && t.meta.genre) genres.add(t.meta.genre);
                        if(t.meta && t.meta.age_recommendation) ages.add(t.meta.age_recommendation);
                    });

                    // Alter Sortieren
                    Array.from(ages).sort((a,b) => a-b).forEach(age => {
                        addFilterChip(`Ab ${age} Jahren`, `age_${age}`);
                    });
                    
                    // Genre hinzuf√ºgen
                    Array.from(genres).sort().forEach(genre => {
                         addFilterChip(genre, `genre_${genre}`);
                    });
                }

                // --- ZULETZT GEH√ñRT SEKTION (nur bei 'all' oder 'recent') ---
                if (currentLibFilter === 'all' || currentLibFilter === 'recent') {
                    const recentTracks = [...tracks].filter(t => t.lastPlayedTimestamp).sort((a, b) => b.lastPlayedTimestamp - a.lastPlayedTimestamp).slice(0, 3);
                    
                    if (recentTracks.length > 0) {
                        const recentDiv = document.createElement('div');
                        recentDiv.innerHTML = `<div class="section-title">Zuletzt geh√∂rt üïí</div><div class="recent-grid" id="recent-grid-target"></div>`;
                        contentArea.appendChild(recentDiv);
                        const target = recentDiv.querySelector('#recent-grid-target');
                        
                        recentTracks.forEach(t => {
                            target.appendChild(createLibCard(t, true));
                        });
                    }
                }

                if (currentLibFilter === 'recent') return; // Bei "Recent" zeigen wir nur die oberen an

                // --- HAUPT GRID ---
                const gridDiv = document.createElement('div');
                gridDiv.className = 'library-grid';
                if(currentLibFilter === 'all') gridDiv.style.marginTop = "20px";
                
                // Filtern
                let filteredTracks = tracks;
                if (currentLibFilter.startsWith('age_')) {
                    const age = parseInt(currentLibFilter.split('_')[1]);
                    // Zeige alle, die f√ºr dieses Alter ODER j√ºnger geeignet sind, ODER exakt dieses Alter
                    filteredTracks = tracks.filter(t => t.meta && t.meta.age_recommendation == age);
                } else if (currentLibFilter.startsWith('genre_')) {
                    const g = currentLibFilter.replace('genre_', '');
                    filteredTracks = tracks.filter(t => t.meta && t.meta.genre === g);
                }

                // Sortieren (Alphabetisch)
                filteredTracks.sort((a, b) => a.name.localeCompare(b.name));

                filteredTracks.forEach(t => {
                    gridDiv.appendChild(createLibCard(t));
                });
                
                contentArea.appendChild(gridDiv);
            };
        }

        function addFilterChip(label, value) {
            const container = document.getElementById('lib-filters');
            if(container.querySelector(`[data-val="${value}"]`)) return;
            
            const chip = document.createElement('div');
            chip.className = 'filter-chip';
            chip.innerText = label;
            chip.dataset.val = value;
            chip.onclick = function() { applyLibFilter(value, this); };
            container.appendChild(chip);
        }

        function applyLibFilter(filterVal, el) {
            currentLibFilter = filterVal;
            document.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('active'));
            if(el) el.classList.add('active');
            renderLibrary();
        }

        function createLibCard(track, isSmall = false) {
            const div = document.createElement('div');
            div.className = isSmall ? 'recent-card' : 'lib-card';
            div.onclick = () => {
                closeLibrary();
                playTrackByTag(track.tagId);
            };

            let imgHtml = `<div class="lib-placeholder">üéµ</div>`;
            if (track.imageBlob) {
                const url = URL.createObjectURL(track.imageBlob);
                imgHtml = `<img src="${url}" class="lib-cover-img" loading="lazy">`;
            } else if (track.imageFileName === "Standard") {
                 // Fallback Logic falls n√∂tig
            }

            // INFO BUTTON EINBAUEN
            let infoBtnHtml = "";
            if(!isSmall) { // Info Button nur auf gro√üen Karten
                 infoBtnHtml = `<button class="lib-card-info-btn" onclick="showAlbumInfo(event, '${track.tagId}')">i</button>`;
            }

            let metaInfo = "";
            if(!isSmall && track.meta) {
                 if(track.meta.runtime) metaInfo += `‚è±Ô∏è ${track.meta.runtime} min`;
            }

            div.innerHTML = `
                <div class="lib-cover-wrap" style="${isSmall ? 'border-radius:10px;' : ''}">
                    ${imgHtml}
                    ${infoBtnHtml}
                </div>
                ${!isSmall ? `
                <div class="lib-card-body">
                    <div class="lib-card-title">${track.name}</div>
                    <span class="lib-meta-tag">${metaInfo}</span>
                </div>` : ''}
            `;
            return div;
        }

        // --- ALBUM INFO MODAL LOGIC ---
        function showAlbumInfo(event, tagId) {
            event.stopPropagation(); // Verhindert dass das Album gestartet wird
            
            const store = db.transaction(["tracks"], "readonly").objectStore("tracks");
            store.get(tagId).onsuccess = (e) => {
                const track = e.target.result;
                if(!track) return;

                const modal = document.getElementById('lib-info-modal');
                const imgEl = document.getElementById('info-modal-img');
                const titleEl = document.getElementById('info-modal-title');
                const metaEl = document.getElementById('info-modal-meta');
                const descEl = document.getElementById('info-modal-desc');

                // Bild
                if(track.imageBlob) imgEl.src = URL.createObjectURL(track.imageBlob);
                else imgEl.src = "";

                // Text
                titleEl.innerText = track.name;
                
                // Meta
                let metaText = [];
                if(track.meta) {
                    if(track.meta.age_recommendation) metaText.push(`Ab ${track.meta.age_recommendation} J.`);
                    if(track.meta.genre) metaText.push(track.meta.genre);
                    if(track.meta.runtime) metaText.push(`${track.meta.runtime} min`);
                }
                metaEl.innerText = metaText.join(" ‚Ä¢ ");

                // Beschreibung (Description)
                if(track.meta && track.meta.description) {
                    descEl.innerText = track.meta.description;
                    descEl.style.display = 'block';
                } else {
                    descEl.style.display = 'none';
                }

                modal.style.display = 'flex';
            };
        }

        function closeAlbumInfo() {
            document.getElementById('lib-info-modal').style.display = 'none';
        }

        if ('serviceWorker' in navigator) { navigator.serviceWorker.register('sw.js'); }
    </script>
</body>
</html>
