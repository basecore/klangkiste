<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KlangKiste V80 (Mobile Fix) </title>
    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2ecc71">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <link rel="icon" type="image/png" href="assets/icons/icon.png">
    <link rel="apple-touch-icon" href="assets/icons/icon.png">

    <style>
        /* --- GRUNDDESIGN --- */
        :root {
            --bg-color: #f4f7f6;
            --green-safe: #2ecc71;
            --orange-warn: #f1c40f;
            --red-danger: #ff4757;
            --blue-time: #3498db;
            --purple-admin: #9b59b6;
            --yellow-btn: #f1c40f;
            --blue-btn: #3498db;
            --purple-btn: #9b59b6;
            --btn-color: #dfe4ea;
            --text: #2f3542;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text);
            margin: 0; height: 100vh; overflow: hidden;
            display: flex; flex-direction: column;
            user-select: none; -webkit-tap-highlight-color: transparent;
        }

        /* SCHWARZER VORHANG F√úR ECO MODUS */
        #black-curtain {
            display: none;
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: black;
            z-index: 99999;
            pointer-events: auto;
        }

        /* KIDS MODE UI */
        #kids-mode {
            display: none; 
            position: fixed; 
            top: 0; left: 0; right: 0; bottom: 0;
            width: 100%; height: 100%;
            flex-direction: column;
            align-items: center; justify-content: flex-start;
            background-color: #2c3e50; /* Dunkler Fallback */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            padding: 20px; padding-top: 60px; /* Platz f√ºr Titel und Buttons */
            box-sizing: border-box;
            transition: background 0.3s ease;
            z-index: 50; 
            overflow-y: auto; 
            overflow-x: hidden;
        }
        
        .kids-text-shadow {
            text-shadow: 0 1px 3px rgba(255,255,255, 0.8);
            background: rgba(255, 255, 255, 0.65);
            padding: 5px 15px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: inline-block;
        }

        #track-title-display {
            font-size: 2.2rem; font-weight: 800; color: #2c3e50;
            margin-bottom: 20px; text-align: center; width: 95%;
            line-height: 1.1; 
            display: -webkit-box; -webkit-line-clamp: 3; 
            -webkit-box-orient: vertical; overflow: hidden; 
            white-space: normal; min-height: 6.5rem; 
            margin-top: 15px;
        }
        
        #playlist-info {
            font-size: 1rem; color: #f1f2f6; text-shadow: 0 1px 2px black;
            margin-top: -15px; margin-bottom: 10px; font-weight: bold;
            max-width: 90%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }

        #album-art-container {
            width: 45vw; height: 45vw; border-radius: 20px;
            margin-bottom: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            background-color: #eee; overflow: hidden;
            display: flex; align-items: center; justify-content: center;
            border: 4px solid white; position: relative;
        }

        #album-img { width: 100%; height: 100%; object-fit: cover; display: none; }
        #album-placeholder { font-size: 60px; color: #ccc; }

        #sleep-indicator {
            position: absolute; top: 10px; right: 10px; font-size: 16px;
            background: rgba(255,255,255,0.9); padding: 5px 10px;
            border-radius: 12px; display: none; color: #333;
            font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.1); 
        }

        /* CONTROLS */
        .controls-main {
            display: flex; align-items: center; justify-content: center;
            gap: 25px; margin-bottom: 15px; width: 100%;
        }

        #volume-display-container {
            width: 85%; height: 25px; background-color: rgba(255,255,255,0.7);
            border-radius: 15px; overflow: hidden; border: 1px solid rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        #volume-bar {
            height: 100%; width: 50%; background-color: var(--green-safe);
            transition: width 0.2s, background-color 0.5s;
        }

        .controls-nav-row {
            display: flex; align-items: center; justify-content: center;
            gap: 20px; width: 100%; margin-bottom: 40px; 
        }
        
        .btn-control {
            border: none; border-radius: 50%; cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.15); display: flex;
            align-items: center; justify-content: center; font-weight: bold;
            transition: transform 0.1s; color: #576574; 
        }

        .btn-control:active { transform: scale(0.92); }
        .btn-control svg { width: 50%; height: 50%; fill: currentColor; }

        .btn-play {
            width: 110px; height: 110px; background-color: var(--green-safe); color: white;
        }
        .btn-play svg { width: 60%; height: 60%; }

        .btn-secondary {
            width: 75px; height: 75px; background-color: var(--btn-color); color: #2f3542;
        }

        .btn-colorful-vol-down { background-color: var(--yellow-btn) !important; color: #333 !important; }
        .btn-colorful-vol-up { background-color: var(--red-danger) !important; color: white !important; }
        .btn-colorful-back { background-color: var(--blue-btn) !important; color: white !important; }
        .btn-colorful-skip { background-color: var(--purple-btn) !important; color: white !important; }
        .btn-colorful-rewind { background-color: #e17055 !important; color: white !important; }
        .btn-colorful-next { background-color: #00cec9 !important; color: white !important; }

        #time-container {
            width: 90%; height: 45px; background-color: rgba(255,255,255, 0.8);
            border-radius: 12px; position: relative; overflow: hidden;
            border: 1px solid rgba(0,0,0,0.1); cursor: pointer; margin-top: auto; 
            margin-bottom: 20px;
        }
        #time-progress { height: 100%; width: 0%; background-color: var(--blue-time); transition: width 0.5s linear; }
        #time-text {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            color: #2c3e50; font-weight: bold; font-size: 1.3rem;
            text-shadow: 0 0 2px rgba(255,255,255,0.8);
            font-variant-numeric: tabular-nums;
        }
        
        /* --- LIBRARY MODE --- */
        #library-mode {
            display: none; 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #2c3e50;
            z-index: 60;
            overflow-y: auto;
            padding: 20px; box-sizing: border-box;
            padding-top: 50px; 
            padding-bottom: 90px;
        }

        .lib-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; margin-top: 10px;
        }

        .lib-title {
            color: white; font-size: 1.5rem; font-weight: bold; text-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        /* Filter Leiste */
        .filter-scroll-container {
            display: flex; gap: 10px; overflow-x: auto; 
            padding-bottom: 15px; 
            padding-top: 5px;
            margin-bottom: 20px;
            scrollbar-width: none;
            min-height: 55px;
            flex-shrink: 0;
        }
        .filter-scroll-container::-webkit-scrollbar { display: none; }

        .filter-chip {
            background: rgba(255,255,255,0.2); color: white;
            padding: 8px 16px; border-radius: 20px; white-space: nowrap;
            font-size: 0.9rem; border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.2s; cursor: pointer;
            height: 36px; display: flex; align-items: center;
        }
        .filter-chip.active {
            background: var(--green-safe); border-color: var(--green-safe); font-weight: bold;
            box-shadow: 0 4px 10px rgba(46, 204, 113, 0.4);
        }

        /* Recent Section */
        .section-title { 
            color: #dfe6e9; font-size: 1.1rem; 
            margin-bottom: 15px; margin-top: 10px; 
            font-weight: bold; 
            clear: both;
        }
        
        .recent-grid {
            display: flex; gap: 15px; overflow-x: auto; padding-bottom: 15px; margin-bottom: 25px;
        }
        .recent-card {
            min-width: 120px; width: 120px; display: flex; flex-direction: column; gap: 5px; position: relative;
        }

        /* Main Grid */
        .library-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 15px;
            padding-bottom: 20px;
        }

        .lib-card {
            background: white; border-radius: 15px; overflow: hidden;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: transform 0.1s; position: relative;
        }
        .lib-card:active { transform: scale(0.96); }

        .lib-cover-wrap {
            width: 100%; aspect-ratio: 1 / 1; background: #eee;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden; position: relative;
        }
        .lib-cover-img { width: 100%; height: 100%; object-fit: cover; }
        .lib-placeholder { font-size: 40px; }

        /* CHECKMARK */
        .completed-badge {
            position: absolute; bottom: 5px; right: 5px;
            background: #2ecc71; color: white; border-radius: 50%;
            width: 28px; height: 28px; display: flex;
            align-items: center; justify-content: center;
            font-size: 16px; border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4); z-index: 10;
        }

        .lib-card-body { padding: 10px; }
        .lib-card-title {
            font-size: 0.9rem; font-weight: bold; color: #2d3436;
            display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;
            line-height: 1.2; height: 2.4em;
        }
        .lib-meta-tag {
            font-size: 0.7rem; color: #636e72; margin-top: 5px; display: block;
        }

        .lib-card-info-btn {
            position: absolute; top: 8px; right: 8px;
            width: 30px; height: 30px; border-radius: 50%;
            background: rgba(255,255,255,0.9);
            color: #2980b9; border: none;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-family: serif; font-size: 1.1rem; font-style: italic;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 5;
        }

        #btn-close-lib {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--red-danger); color: white;
            padding: 15px 30px; border-radius: 30px; border: none;
            font-size: 1.1rem; font-weight: bold; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 70;
        }

        #btn-open-lib {
            position: fixed; top: 20px; left: 20px;
            background: rgba(255,255,255,0.25); color: white;
            border: none; width: 55px; height: 55px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(5px); 
            z-index: 100;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        /* INFO MODAL */
        #lib-info-modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 80;
            align-items: center; justify-content: center; padding: 20px; box-sizing: border-box;
        }
        .info-modal-content {
            background: white; width: 100%; max-width: 400px; max-height: 80vh;
            border-radius: 20px; padding: 25px; overflow-y: auto;
            position: relative; text-align: center;
        }
        .info-modal-cover {
            width: 120px; height: 120px; border-radius: 10px; object-fit: cover;
            margin-bottom: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .info-modal-h { font-size: 1.2rem; font-weight: bold; color: #2c3e50; margin-bottom: 5px; }
        .info-modal-meta { color: #7f8c8d; font-size: 0.9rem; margin-bottom: 15px; }
        .info-modal-desc { 
            text-align: left; font-size: 0.95rem; line-height: 1.5; color: #34495e; 
            background: #f7f9fa; padding: 15px; border-radius: 10px;
        }
        .btn-close-modal {
            background: #2ecc71; color: white; border: none; padding: 10px 20px;
            border-radius: 20px; margin-top: 20px; font-weight: bold; width: 100%;
        }

        /* STATS MODAL & TIMELINE */
        #stats-modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #2d3436; 
            z-index: 20000;
            padding: 20px; box-sizing: border-box; flex-direction: column; overflow-y: auto;
        }
        .stats-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; border-bottom: 1px solid #555; padding-bottom: 10px;
            position: relative; 
        }
        .stats-title { font-size: 1.5rem; color: #74b9ff; font-weight: bold; }
        
        .stats-close-btn { 
            background: #e74c3c; border: none; color: white; width: 45px; height: 45px; 
            border-radius: 50%; font-weight: bold; font-size: 1.2rem; 
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            position: relative; z-index: 20001; pointer-events: auto;
        }
        .stats-close-btn:active { transform: scale(0.9); }

        .stat-card {
            background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px;
            margin-bottom: 15px; border: 1px solid rgba(255,255,255,0.1);
        }
        .stat-val-big { font-size: 2rem; font-weight: bold; color: #2ecc71; margin-bottom: 5px; }
        .stat-label { font-size: 0.9rem; color: #aaa; text-transform: uppercase; letter-spacing: 1px; }
        
        .stats-toggle-btn {
            background: #555; color: #ddd; border: none; padding: 10px 15px;
            border-radius: 20px; font-weight: bold; font-size: 0.9rem;
            cursor: pointer; transition: all 0.2s; flex: 1; text-align: center;
        }
        .stats-toggle-btn.active {
            background: #3498db; color: white; box-shadow: 0 4px 10px rgba(52, 152, 219, 0.4);
        }
        
        /* Balken Diagramm Simple */
        .chart-row { display: flex; align-items: center; margin-bottom: 8px; font-size: 0.85rem; }
        .chart-label { width: 120px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: #dfe6e9; }
        .chart-bar-bg { flex: 1; height: 12px; background: rgba(255,255,255,0.1); border-radius: 6px; overflow: hidden; margin-left: 10px; }
        .chart-bar-fill { height: 100%; background: #3498db; width: 0%; border-radius: 6px; transition: width 0.5s; }
        .chart-val { width: 40px; text-align: right; color: #aaa; font-size: 0.8rem; margin-left: 5px; }

        /* --- TIMELINE STATS DESIGN --- */
        .timeline-container {
            margin-top: 20px;
            border-left: 2px solid #555;
            padding-left: 20px;
            margin-left: 10px;
        }
        .timeline-item {
            position: relative;
            margin-bottom: 20px;
        }
        .timeline-dot {
            position: absolute;
            left: -26px; top: 0;
            width: 10px; height: 10px;
            border-radius: 50%;
            background: #3498db;
            border: 2px solid #2d3436;
        }
        .timeline-time {
            font-size: 0.75rem; color: #aaa; margin-bottom: 2px; font-family: monospace;
        }
        .timeline-content {
            background: rgba(255,255,255,0.05);
            padding: 10px; border-radius: 6px;
            font-size: 0.9rem; color: #dfe6e9;
        }
        .timeline-detail {
            font-size: 0.8rem; color: #7f8c8d; margin-top: 5px; font-style: italic;
        }
        .tl-icon { margin-right: 5px; }

        /* PARENT MODE UI */
        #parent-mode {
            display: flex; flex-direction: column; padding: 20px;
            height: 100vh; background-color: #2d3436; color: white;
            overflow-y: auto;
            z-index: 10;
        }

        .card {
            background: rgba(255,255,255,0.1); padding: 15px;
            border-radius: 10px; margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .card.editing-highlight {
            border: 2px solid #3498db;
            background: rgba(52, 152, 219, 0.1);
        }

        h2 { margin-top: 0; font-size: 1.1rem; color: #74b9ff; }

        input[type="file"], input[type="text"], select {
            width: 100%; padding: 12px; background: rgba(0,0,0,0.3);
            border: 1px solid #555; border-radius: 5px; color: white;
            box-sizing: border-box; margin-bottom: 10px;
        }
        input[type="color"] {
            width: 100%; height: 50px; padding: 5px; background: none; border: 1px solid #555; cursor: pointer;
        }

        .checkbox-wrapper { display: flex; align-items: center; margin-bottom: 15px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px;}
        .checkbox-wrapper input { width: auto; margin-right: 15px; transform: scale(1.5); }
        .checkbox-wrapper span { font-size: 0.9em; }

        label { display: block; margin-bottom: 5px; font-size: 0.9em; color: #aaa; }
        
        .file-info { 
            font-size: 0.8em; color: #00cec9; margin-top:-5px; margin-bottom: 10px; display: block; font-style: italic; 
            white-space: normal; 
            word-wrap: break-word; 
            word-break: break-all;
            line-height: 1.3;
        }

        button.btn-admin {
            background-color: #74b9ff; border: none; padding: 12px;
            border-radius: 8px; color: #2d3436; font-weight: bold;
            font-size: 16px; width: 100%; margin-top: 10px; cursor: pointer;
        }
        button.btn-admin:disabled {
            opacity: 0.5; cursor: not-allowed; filter: grayscale(100%);
        }

        .btn-io-group { display: flex; gap: 10px; margin-top: 10px; }
        .btn-export { background-color: var(--purple-admin); color: white; }
        .btn-import { background-color: var(--green-safe); color: white; position: relative;}
        .btn-relink { background-color: var(--orange-warn); color: #333; position: relative; margin-top:10px; width: 100%;}
        
        #import-file-hidden, #relink-file-hidden, #bg-img-hidden, #bulk-folder-input, #repair-folder-input, #bulk-folder-struct-input {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0; cursor: pointer;
        }

        .btn-switch-kids {
            background-color: var(--green-safe); color: white; padding: 15px;
            border: none; border-radius: 10px; font-size: 1.2rem;
            font-weight: bold; width: 100%; margin-bottom: 15px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .hint-text {
            background: rgba(255, 165, 2, 0.2); padding: 10px;
            border-radius: 5px; font-size: 0.85em; margin-bottom: 20px;
            border-left: 3px solid orange;
        }
        
        .warn-text {
            background: rgba(231, 76, 60, 0.2); padding: 10px;
            border-radius: 5px; font-size: 0.85em; margin-top: 5px; margin-bottom: 15px;
            border-left: 3px solid #e74c3c; color: #e74c3c; font-weight: bold;
        }
        
        .info-box-blue {
            background: rgba(52, 152, 219, 0.2); padding: 10px;
            border-radius: 5px; font-size: 0.85em; margin-bottom: 10px;
            border-left: 3px solid #3498db; color: #dfe6e9;
        }

        .footer-info {
            margin-top: auto; padding-top: 20px; padding-bottom: 20px;
            text-align: center; font-size: 0.75em; color: #888;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        .footer-info a { color: #74b9ff; text-decoration: none; font-weight: bold; }
        .footer-info a:hover { text-decoration: underline; }

        /* --- ADMIN GRID / LIST VIEW --- */
        .admin-view-controls {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px;
        }
        .view-toggle-btn {
            background: none; border: 1px solid #7f8c8d; color: #dfe6e9;
            padding: 5px 10px; border-radius: 5px; cursor: pointer; margin-left: 5px;
        }
        .view-toggle-btn.active {
            background: #3498db; border-color: #3498db; color: white;
        }

        .admin-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 15px;
        }
        
        .admin-list {
            display: flex; flex-direction: column; gap: 5px; /* List styling */
        }

        /* --- OPTIMIZED LIST ROW (NEW) --- */
        .admin-list-row {
            display: flex; align-items: center;
            background: rgba(255,255,255,0.1); 
            border-bottom: 1px solid #444;
            padding: 8px 10px;
            border-radius: 5px;
        }
        .list-icon { 
            font-size: 20px; margin-right: 10px; min-width: 30px; text-align: center; 
        }
        .list-info { flex: 1; overflow: hidden; }
        .list-name { font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.9rem; }
        .list-meta { font-size: 0.7rem; color: #aaa; font-family: monospace; }

        /* Neu: Kleines Coverbild f√ºr die Liste */
        .list-img-small {
            width: 45px; height: 45px; 
            border-radius: 5px; 
            object-fit: cover; 
            margin-right: 10px;
            background: #333;
        }

        /* --- GRID CARD (OLD) --- */
        .admin-card {
            background: rgba(255,255,255,0.1); border-radius: 10px; overflow: hidden;
            position: relative; border: 1px solid rgba(255,255,255,0.1);
            display: flex; flex-direction: column;
        }
        
        .admin-cover-wrap {
            width: 100%; aspect-ratio: 1/1; position: relative;
            background: #333; display: flex; align-items: center; justify-content: center;
        }
        .admin-cover-img { width: 100%; height: 100%; object-fit: cover; }
        
        .admin-card-body { padding: 10px; flex-grow: 1; display: flex; flex-direction: column; justify-content: space-between;}
        .admin-card-title { font-size: 0.9em; font-weight: bold; margin-bottom: 5px; line-height: 1.2; }
        .admin-card-id { font-size: 0.7em; color: #aaa; margin-bottom: 8px; font-family: monospace; word-break: break-all;}
        
        .admin-actions {
            display: flex; gap: 5px; margin-top: auto;
        }
        .btn-mini {
            flex: 1; border: none; padding: 5px; border-radius: 4px; 
            font-size: 0.75em; cursor: pointer; color: white; font-weight: bold;
        }
        .btn-mini:disabled { opacity: 0.3; cursor: not-allowed; }
        .btn-mini.edit { background-color: #3498db; }
        .btn-mini.play { background-color: #2ecc71; }
        .btn-mini.vis { background-color: #f39c12; }
        .btn-mini.del { background-color: #e74c3c; flex: 0 0 30px; }

        .meta-details-container {
            background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; margin-top: 10px;
            border-left: 3px solid #f1c40f;
        }
        .meta-row { display: flex; gap: 10px; }
        .meta-row input { flex: 1; }
        textarea.input-desc {
            width: 100%; height: 80px; padding: 10px; background: rgba(0,0,0,0.3);
            border: 1px solid #555; border-radius: 5px; color: white; font-family: sans-serif;
            resize: vertical;
        }

        #mode-switch-secret { position: fixed; top: 0; right: 0; width: 80px; height: 80px; z-index: 9999; }

        #status-msg {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.9); color: white; padding: 10px 20px;
            border-radius: 30px; display: none; z-index: 1000; text-align: center;
        }

        #flash-overlay {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(46, 204, 113, 0.5); pointer-events: none;
            opacity: 0; transition: opacity 0.2s; z-index: 2000;
        }

        .browser-warning {
            background-color: #ff4757; color: white; padding: 15px;
            border-radius: 10px; margin-bottom: 20px; display: none;
        }

        .hidden-container { display: none; }
        
        #stubborn-video {
            position: fixed; top: 0; left: 0; width: 1px; height: 1px; opacity: 0.01; pointer-events: none;
        }

        /* --- IMPORT SELECTION MODAL --- */
        #import-modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 30000;
            flex-direction: column; padding: 15px; box-sizing: border-box;
        }

        .import-header {
            background: #2d3436; padding: 15px; border-radius: 10px 10px 0 0;
            border-bottom: 2px solid #555; display: flex; flex-direction: column; gap: 10px;
        }

        .import-controls { display: flex; gap: 10px; flex-wrap: wrap; }

        .import-list {
            background: #2d3436; flex: 1; overflow-y: auto;
            padding: 10px; border-radius: 0 0 10px 10px;
        }

        .import-item {
            display: flex; align-items: center; padding: 10px;
            border-bottom: 1px solid #444; background: rgba(255,255,255,0.05);
            margin-bottom: 5px; border-radius: 5px;
        }

        .import-checkbox { width: 24px; height: 24px; margin-right: 15px; cursor: pointer; }

        .import-info { flex: 1; overflow: hidden; }
        .import-name { font-weight: bold; color: #dfe6e9; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .import-meta { font-size: 0.8em; color: #aaa; }

        .btn-modal-action {
            padding: 10px; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; flex: 1;
        }
        .btn-confirm { background: #2ecc71; color: white; }
        .btn-cancel { background: #e74c3c; color: white; }
        .btn-filter { background: #3498db; color: white; font-size: 0.8em; }
    </style>
</head>
<body>

    <div id="black-curtain"></div>
    
    <video id="stubborn-video" playsinline muted loop style="position:fixed; top:0; left:0; width:1px; height:1px; opacity:0.01; pointer-events:none;"></video>

    <div id="mode-switch-secret" onclick="handleSecretSwitch()"></div>
    
    <div id="flash-overlay"></div>

    <div id="import-modal">
        <div class="import-header">
            <h2 style="margin:0; color:white; font-size:1.2em;">üì• Import Auswahl</h2>
            <div style="font-size:0.85em; color:#f1c40f; font-weight:bold; background:rgba(241, 196, 15, 0.2); padding:5px; border-radius:5px;">‚ö†Ô∏è Achtung: Speichert im Browser-Cache.</div>
            
            <div style="font-size:0.75em; color:#aaa; margin-bottom:2px;">
                üí° Tipp: <b>-text</b> zum Ausschlie√üen. (z.B. <i>conni -kater</i>)
            </div>
            
            <input type="text" id="import-search" placeholder="üîç Suche (z.B. 'conni -pixi')..." onkeyup="filterImportList()" style="width:100%; margin-bottom:5px; padding:12px; box-sizing: border-box;">
            
            <div style="display:flex; gap:10px; margin-bottom:5px;">
                <input type="number" id="import-min-age" placeholder="Ab J." onkeyup="filterImportList()" onchange="filterImportList()" style="margin-bottom:0; flex:1; padding:10px; min-width:0; box-sizing: border-box;">
                <input type="number" id="import-max-age" placeholder="Bis J." onkeyup="filterImportList()" onchange="filterImportList()" style="margin-bottom:0; flex:1; padding:10px; min-width:0; box-sizing: border-box;">
            </div>
            
            <div class="import-controls" style="margin-top:5px; display:flex; gap:5px;">
                <button class="btn-modal-action btn-filter" style="background:#27ae60;" onclick="handleSelection('exclusive')">‚úÖ Nur diese (Rest aus)</button>
                <button class="btn-modal-action btn-filter" style="background:#e67e22;" onclick="handleSelection('clear_visible')">‚¨ú Sichtbare abw√§hlen</button>
            </div>
        </div>
        <div id="import-list-container" class="import-list">
            </div>
        <div style="display:flex; gap:10px; margin-top:10px;">
            <button class="btn-modal-action btn-cancel" onclick="closeImportModal()">Abbruch</button>
            <button class="btn-modal-action btn-confirm" onclick="executeImport()">‚úÖ START</button>
        </div>
    </div>

    <div id="parent-mode">
        <button class="btn-switch-kids" onclick="goToKidsMode()">‚ñ∂ ZUM KINDER-MODUS</button>
        <div class="hint-text">üí° Tipp: 5x oben rechts tippen f√ºr Admin-Men√º.</div>
        
        <div style="display:flex; justify-content:space-between; align-items:center;">
             <h1>üîß KlangKiste</h1>
             <button onclick="openStats()" style="background:none; border:2px solid #3498db; color:#3498db; padding:5px 10px; border-radius:15px; cursor:pointer; font-weight:bold;">üìä Statistik</button>
        </div>

        <div id="nfc-warning" class="browser-warning">‚ö†Ô∏è NFC API nicht verf√ºgbar. Bitte Chrome nutzen.</div>

        <div class="card">
            <h2>‚öôÔ∏è Einstellungen</h2>
            <label>Start-Modus:</label>
            <select id="start-mode-input" onchange="saveSettings()" style="background: rgba(46, 204, 113, 0.2); border: 1px solid #2ecc71;">
                <option value="parent">Eltern-Modus (Standard)</option>
                <option value="kids">Direkt Kinder-Modus</option>
            </select>

            <label>Maximale Lautst√§rke (Begrenzung):</label>
            <input type="range" id="max-vol-input" min="1" max="100" value="100" style="width:100%" oninput="updateSettingsUI()">
            <div style="display:flex; justify-content: space-between; align-items:center; margin-bottom: 5px;">
                 <span id="vol-display" style="font-size: 0.9em; font-weight:bold;">100%</span>
                 
                 <button class="btn-admin" style="width: auto; margin:0; padding: 5px 15px; background-color: #fab1a0; color: #333; font-size: 0.8em;" onclick="playTestTone()">
                    üîä Test-Ton (Limit)
                 </button>
            </div>
            
            <div class="warn-text">
                ‚ö†Ô∏è Wichtig: Bitte stelle die Handy-Lautst√§rke (Hardware-Tasten) auf 100%.
            </div>
            
            <label>Schlaf-Timer:</label>
            <select id="sleep-timer-input" onchange="saveSettings()" style="margin-bottom: 15px;">
                <option value="0">Aus (Endlos)</option>
                <option value="10">10 Minuten</option>
                <option value="20">20 Minuten</option>
                <option value="30">30 Minuten</option>
                <option value="60">1 Stunde</option>
            </select>
        </div>

        <div class="card" style="border-left: 3px solid #0984e3;">
            <h2>üîã Energie & Display</h2>
            <div class="checkbox-wrapper">
                <input type="checkbox" id="check-wakelock" onchange="saveSettings()" checked>
                <div><strong>Display anlassen</strong><br><span style="font-size:0.8em; color:#ccc;">Nutzt Video-Trick + WakeLock</span></div>
            </div>
            <div class="checkbox-wrapper">
                <input type="checkbox" id="check-ecomode" onchange="updateEcoModeState(true)" checked>
                <div><strong>Stromsparen beim Umdrehen</strong><br><span style="font-size:0.8em; color:#ccc;">Display aus bei Face-down</span></div>
            </div>
            <button class="btn-admin" style="background-color: #74b9ff; font-size: 0.9em; margin-top:0;" onclick="requestIOSPermission()">
                üì± iOS Sensoren aktivieren
            </button>
        </div>

        <div class="card" style="border-left: 3px solid #e84393;">
            <h2>üé® Design f√ºr Kinder-Modus</h2>
            <div class="checkbox-wrapper">
                <input type="checkbox" id="check-enable-lib" onchange="saveSettings()" checked>
                <div><strong>üìö Bibliothek im Kinder-Modus erlauben</strong><br><span style="font-size:0.8em; color:#ccc;">Deaktivieren f√ºr reine Tag-Steuerung</span></div>
            </div>
            <div class="checkbox-wrapper">
                <input type="checkbox" id="check-colorful" onchange="saveSettings()" checked>
                <span><strong>üé® Bunte Kn√∂pfe f√ºr Kinder</strong></span>
            </div>
            
            <label>Hintergrund-Modus:</label>
            <select id="bg-mode-select" onchange="updateBgUIState(); saveSettings();" style="margin-bottom: 15px;">
                <option value="default">Standard</option>
                <option value="color">Farbe</option>
                <option value="image">Bild</option>
            </select>
            <div id="bg-color-container" class="hidden-container"> 
                 <input type="color" id="bg-color-input" value="#ffffff" onchange="saveSettings()">
            </div>
            <div id="bg-image-container" class="hidden-container">
                <button class="btn-admin" style="background-color: #6c5ce7; position:relative;">
                    üñºÔ∏è Bild hochladen...
                    <input type="file" id="bg-img-hidden" accept="image/*" onchange="saveBackgroundImage(this)">
                </button>
                <button class="btn-admin" style="background-color: #ff7675; margin-top:5px;" onclick="deleteBackgroundImage()">L√∂schen</button>
            </div>
        </div>
        
        <div class="card" style="border-left: 3px solid #9b59b6;">
            <h2>üìö Bibliothek & Inhalte</h2>
            <p style="font-size:0.85em; color:#ccc; margin-top:-10px; margin-bottom:15px;">Steuerung, was in der Bibliothek angezeigt wird.</p>

            <label>Alters-Filter (Global):</label>
            <div class="info-box-blue" style="margin-top:0; margin-bottom:10px;">
                Zeigt nur Inhalte bis zu diesem Alter.
            </div>
            <select id="lib-max-age-select" onchange="saveSettings()" style="margin-bottom: 15px;">
                <option value="99">Alle anzeigen (Kein Filter)</option>
                <option value="0">Nur "0 Jahre" / Ohne Altersangabe</option>
                <option value="1">Bis 1 Jahr</option>
                <option value="2">Bis 2 Jahre</option>
                <option value="3">Bis 3 Jahre</option>
                <option value="4">Bis 4 Jahre</option>
                <option value="5">Bis 5 Jahre</option>
                <option value="6">Bis 6 Jahre</option>
                <option value="8">Bis 8 Jahre</option>
                <option value="10">Bis 10 Jahre</option>
                <option value="12">Bis 12 Jahre</option>
            </select>
            
            <hr style="border-top:1px solid rgba(255,255,255,0.1); margin:15px 0;">
            
            <label>Massen-Steuerung:</label>
            <div class="btn-io-group">
                <button class="btn-admin" style="background-color: #2d3436; color:white; border: 1px solid #555;" onclick="setAllLibraryVisibility(true)">
                      üö´ Alle verstecken
                </button>
                <button class="btn-admin" style="background-color: #2ecc71; color:white;" onclick="setAllLibraryVisibility(false)">
                      üëÅÔ∏è Alle anzeigen
                </button>
            </div>
        </div>

        <div class="card" id="scan-card">
            <h2 id="form-title">üéµ Tag bearbeiten / anlernen</h2>
            
            <label>1. Audio & Quellen</label>
            <input type="file" id="audio-input" multiple accept="audio/*, .m4a, .mp3, .ogg, .wav, .flac" onchange="autoFillName()">
            <span id="audio-info" class="file-info"></span>
            
            <div style="display:flex; gap:10px;">
                <div style="flex:1; min-width: 0;"> <label style="font-size:0.8em;">Cue (Optional)</label>
                    <input type="file" id="cue-input" accept=".cue">
                    <span id="cue-info" class="file-info"></span>
                </div>
                <div style="flex:1; min-width: 0;"> <label style="font-size:0.8em;">Cover Bild</label>
                    <input type="file" id="img-input" accept="image/*">
                    <span id="img-info" class="file-info"></span>
                </div>
            </div>

            <label>2. Titel</label>
            <input type="text" id="track-name" placeholder="Name des H√∂rspiels...">
            
            <details>
                <summary style="cursor:pointer; color:#f1c40f; margin-bottom:10px; font-weight:bold;">üìù Erweiterte Infos (f√ºr Bibliothek)</summary>
                <div class="meta-details-container">
                    <label>Beschreibung (Inhalt):</label>
                    <textarea id="meta-desc" class="input-desc" placeholder="Worum geht es in der Geschichte?"></textarea>
                    
                    <div class="meta-row" style="margin-top:10px;">
                        <div>
                            <label>Alter (Jahre):</label>
                            <input type="number" id="meta-age" placeholder="z.B. 4" style="width:80px;">
                        </div>
                        <div style="flex:1;">
                            <label>Genre:</label>
                            <select id="meta-genre">
                                <option value="H√∂rspiel">H√∂rspiel</option>
                                <option value="Musik">Musik</option>
                                <option value="H√∂rbuch">H√∂rbuch</option>
                                <option value="Wissen">Wissen</option>
                            </select>
                        </div>
                        <div>
                            <label>Laufzeit (Min):</label>
                            <input type="number" id="meta-runtime" placeholder="auto" style="width:80px;">
                        </div>
                    </div>
                </div>
            </details>
            <br>
            
            <div class="checkbox-wrapper" style="background: rgba(231, 76, 60, 0.2); border: 1px solid #e74c3c;">
                <input type="checkbox" id="track-hidden-lib">
                <div><strong>üö´ In Bibliothek verstecken</strong><br><span style="font-size:0.8em; color:#ccc;">Taucht nicht im Kindermodus auf, aber per NFC abspielbar.</span></div>
            </div>
            <br>

            <div style="display:flex; gap:10px; flex-direction:column;">
                <button id="btn-save-tag" class="btn-admin" onclick="activateLinkMode()">üì° Tag scannen & speichern</button>
                <button id="btn-save-manual" class="btn-admin" style="background-color:#7f8c8d; margin-top:0;" onclick="saveManualTrack()">üíæ Ohne NFC speichern</button>
                <button id="btn-cancel-edit" class="btn-admin" style="background-color:#95a5a6; display:none;" onclick="cancelEdit()">Abbrechen</button>
            </div>
            <p id="scan-status" style="color: #74b9ff; margin-top: 10px; font-weight:bold; min-height: 20px;"></p>
        </div>

        <div class="card">
            <div class="admin-view-controls">
                <h2>üíæ Gespeicherte Tags (Admin)</h2>
                <div>
                    <button class="view-toggle-btn active" id="btn-view-list" onclick="setAdminView('list')">‚ò∞</button>
                    <button class="view-toggle-btn" id="btn-view-grid" onclick="setAdminView('grid')">‚ñ¶</button>
                </div>
            </div>
            <div id="tag-list-container" class="admin-list">
                </div>
        </div>

        <div class="card">
            <h2>üìÇ Datenbank</h2>
            
            <div class="info-box-blue">
                <strong>‚ÑπÔ∏è Import-Info:</strong><br>
                Nutze <strong>"Ordner-Struktur"</strong> f√ºr sortierte Alben (1 Ordner = 1 H√∂rbuch).<br>
                Nutze <strong>"Massen-Import"</strong> f√ºr lose Dateien oder wenn du eine <code>klangkiste.json</code> hast.
            </div>

            <button class="btn-admin" style="background-color: #0984e3; margin-top:10px;" onclick="loadExamplesFromGitHub(event)">
                ‚òÅÔ∏è Beispiele direkt laden (Online)
            </button>

            <button class="btn-admin" style="background-color: #16a085; position:relative; margin-bottom:5px;">
                üìÇ Ordner-Struktur importieren (Smart)
                <div style="font-size:0.7em; opacity:0.8;">1 Ordner = 1 H√∂rbuch | Bild im Ordner = Cover</div>
                <input type="file" id="bulk-folder-struct-input" webkitdirectory directory multiple onchange="handleFolderAlbumImport(this)">
            </button>
            <button class="btn-admin" style="background-color: #e67e22; position:relative; margin-bottom:10px;">
                üìÇ Massen-Import (Dateien/Flat)
                <div style="font-size:0.7em; opacity:0.8;">1 MP3 = 1 H√∂rbuch | Unterst√ºtzt klangkiste.json</div>
                <input type="file" id="bulk-folder-input" webkitdirectory directory multiple onchange="handleBulkImport(this)">
            </button>
            
            <div class="btn-io-group">
                <button class="btn-admin btn-export" onclick="exportKlangkisteJson()">üì§ Datenbank exportieren</button>
                <button class="btn-admin btn-import">
                    üì• Datenbank laden
                    <input type="file" id="import-file-hidden" accept=".json" onchange="importKlangkisteJson(this)">
                </button>
            </div>
            <button class="btn-admin btn-relink" id="btn-auto-repair" style="position:relative;">
                ü™Ñ Automatisch reparieren (Dateien verkn√ºpfen)
                <input type="file" id="repair-folder-input" webkitdirectory directory multiple onchange="smartRelinkFiles(this)">
            </button>
            <hr style="margin: 15px 0; border-top:1px solid #555;">
            <button class="btn-admin" style="background-color: #ff4757;" onclick="clearDatabase()">üóëÔ∏è Datenbank leeren</button>
        </div>

        <div class="footer-info">
            <p>KlangKiste NFC V80</p>
            <p>Entwickelt von <b>Sebastian R√∂√üer</b></p>
            <p>
                <a href="https://github.com/basecore/klangkiste/tree/main" target="_blank">GitHub Projekt</a> | 
                <a href="https://github.com/basecore/klangkiste/issues" target="_blank">Hilfe / Issues</a>
            </p>
        </div>
    </div>
    
    <div id="stats-modal">
        <div class="stats-header">
            <div class="stats-title">üìä Nutzung & Statistik</div>
            <button class="stats-close-btn" onclick="closeStats()">‚úï</button>
        </div>
        
        <div style="display:flex; gap:10px; margin-bottom:15px;">
             <button id="btn-stat-day" class="stats-toggle-btn active" onclick="loadStats('day')">Heute</button>
             <button id="btn-stat-week" class="stats-toggle-btn" onclick="loadStats('week')">7 Tage</button>
             <button id="btn-stat-all" class="stats-toggle-btn" onclick="loadStats('all')">Gesamt</button>
        </div>

        <div class="stat-card" style="display:flex; justify-content:space-around; text-align:center;">
            <div>
                <div class="stat-val-big" id="stat-total-time">0h</div>
                <div class="stat-label">H√∂rdauer</div>
            </div>
            <div>
                <div class="stat-val-big" id="stat-avg-session">0m</div>
                <div class="stat-label">√ò Session</div>
            </div>
        </div>

        <div class="stat-card">
             <div class="chart-row">
                 <div class="chart-label">Vollst√§ndig geh√∂rt ‚úÖ</div>
                 <div class="chart-val" id="stat-completed-count" style="width:auto; color:#2ecc71; font-weight:bold; font-size:1.2em;">0</div>
            </div>
        </div>

        <div class="stat-card">
             <div class="stat-label" style="margin-bottom:10px;">Lieblings-H√∂rspiele</div>
             <div id="stats-top-tracks"></div>
        </div>
        
        <div class="stat-card">
             <div class="stat-label" style="margin-bottom:10px;">Tageszeit (H√∂rverhalten)</div>
             <div id="stats-time-heatmap"></div>
        </div>
        
        <div class="stat-card">
             <div class="stats-title" style="font-size:1.1rem; margin-bottom:15px; border-bottom:1px solid #444; padding-bottom:5px;">
                üïí Exakte Timeline
             </div>
             <div id="stats-timeline-list" class="timeline-container">
             </div>
        </div>
    </div>

    <div id="kids-mode">
        <button id="btn-open-lib" onclick="openLibrary()">
            <svg viewBox="0 0 24 24" style="width:60%; height:60%; fill:white;"><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9H9V9h10v2zm-4 4H9v-2h6v2zm4-8H9V5h10v2z"/></svg>
        </button>

        <div id="sleep-indicator">üåô <span id="sleep-countdown"></span></div>
        <div id="track-title-display" class="kids-text-shadow">Bereit zum Spielen!</div>
        <div id="playlist-info" class="kids-text-shadow"></div>
        
        <div id="album-art-container">
            <span id="album-placeholder">üéµ</span>
            <img id="album-img" src="" alt="Cover">
        </div>
        
        <div class="controls-main">
            <button id="btn-vol-down" class="btn-control btn-secondary" onclick="changeVolume(-0.1)">
                <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
            </button>
            <button id="btn-play-main" class="btn-control btn-play" onclick="togglePlay()">
                <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
            </button>
            <button id="btn-vol-up" class="btn-control btn-secondary" onclick="changeVolume(0.1)">
                <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
            </button>
        </div>

        <div id="volume-display-container">
            <div id="volume-bar"></div>
        </div>

        <div class="controls-nav-row">
             <button id="btn-reset" class="btn-control btn-secondary" onclick="restartPlaylist()" title="Reset">
                 <svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>
             </button>
             
             <button id="btn-rewind" class="btn-control btn-secondary" onclick="skipBack()" title="-30s">
                 <svg viewBox="0 0 24 24"><path d="M11 18V6l-8.5 6 8.5 6zm9 0V6l-8.5 6 8.5 6z"/></svg>
             </button>

             <button id="btn-skip" class="btn-control btn-secondary" onclick="skipForward()" title="Skip">
                 <svg viewBox="0 0 24 24"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg>
             </button>
             <button id="btn-next-track" class="btn-control btn-secondary" style="display:none;" onclick="skipToNextCueTrack()" title="Next Track/Chapter">
                 <svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
             </button>
        </div>

        <div id="time-container" onclick="toggleTimeDisplayMode()">
            <div id="time-progress"></div>
            <div id="time-text">--:--</div>
        </div>
    </div>

    <div id="library-mode">
        <div class="lib-header">
            <div class="lib-title">Meine KlangKiste üìö</div>
        </div>

        <div class="filter-scroll-container" id="lib-filters">
            <div class="filter-chip active" onclick="applyLibFilter('all', this)">Alle</div>
            <div class="filter-chip" onclick="applyLibFilter('recent', this)">Zuletzt geh√∂rt</div>
            </div>

        <div id="lib-content-area">
            </div>

        <button id="btn-close-lib" onclick="closeLibrary()">Zur√ºck zum Player</button>
    </div>

    <div id="lib-info-modal" onclick="closeAlbumInfo()">
        <div class="info-modal-content" onclick="event.stopPropagation()">
            <img id="info-modal-img" class="info-modal-cover" src="">
            <div id="info-modal-title" class="info-modal-h">Titel</div>
            <div id="info-modal-meta" class="info-modal-meta">Info</div>
            <div id="info-modal-desc" class="info-modal-desc">Beschreibung...</div>
            <button class="btn-close-modal" onclick="closeAlbumInfo()">Schlie√üen</button>
        </div>
    </div>

    <div id="status-msg"></div>
    <audio id="audio-player"></audio>

    <script>
        // --- SAFE INITIALIZATION ---
        try {
            document.getElementById('library-mode').style.display = 'none';
        } catch(e){}

        let db; let isParentMode = true; let ndef; let clickCount = 0; 
        
        // --- NEUE LOCKING VARIABLEN ---
        let isProcessingDatabase = false; // Verhindert Race Conditions
        let adminListView = true;         // Standard: Listenansicht (Text) f√ºr Performance

        // --- SCHATTEN-LISTE (NEU) ---
        let hiddenTracks = new Set(); // Speichert versteckte IDs im RAM

        const audioPlayer = document.getElementById('audio-player');
        
        let wakeLock = null;
        let currentSessionStart = null; 
        let currentAudioUrl = null; // <--- NEU: Speichert die aktuelle URL zum L√∂schen
        
        let saveInterval = null;
        
        // --- NEUE GLOBALE VARIABLE F√úR DEN IMPORT ---
        let pendingImportCandidates = [];
        let pendingImportCallback = null;

        // --- HELFER: Safe Element Access ---
        function safeDisplay(id, val) {
            const el = document.getElementById(id);
            if(el) el.style.display = val;
        }

        const stubbornVideo = document.getElementById('stubborn-video');
        stubbornVideo.src = "data:video/mp4;base64,AAAAHGZ0eXBNNEVAAAAAAAEAAQAAAAAAAAAAAAAA1W1vb3YAAABsbXZoAAAAAQAAAAAA5G0AAORtAAABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAGGlvZHMAAAAAEICAgAcAT////3//AAACQXRyYWsAAABcdGtoZAAAAAEAAAAAAAAAAAAAAQAAAAEAAAAAAORtAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAADkbQAAAAABAAAAAAABM21kaWEAAAAgbWRoZAAAAAEAAAAAAORtAADkbQAAQBAAABExAAAAAAAAAAA5aGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAABAAAADG1pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAKFzdGJsAAAAp3N0ZHNkAAAAAAAAAAEAAABnYXZjMQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAEAAABIAAAASAAAAAAADqAAAAAAAP//AAAALWF2Y0MBAAAALgEASAAAAAb/gAQACAAAAAAhAAACigAAlzYBAAAAAwEBAAAAAwEBAAAAAGhzdHRzAAAAAAAAAAEAAAABAAABAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAwc3RzegAAAAAAAAAAAAAAAQAAABRzdGNvAAAAAAAAAAEAAACwAAAAYXVkdGEAAAAUY29wcmQAAAAAQmFzZWNvcmU=";
        
        stubbornVideo.addEventListener('pause', () => {
            if (settings.enableWakeLock && !isParentMode && !audioPlayer.paused) {
                stubbornVideo.play().catch(() => {});
            }
        });

        let currentKidsVolumePct = 1.0; 
        let settings = { maxVolume: 1.0, sleepTimerMinutes: 0, colorfulControls: true, startMode: 'parent', bgMode: 'default', bgColor: '#ffffff', enableWakeLock: true, enableEcoMode: true, enableLibrary: true, hiddenIDs: [] };
        let sleepTimerId = null; let showRemainingTime = true; 
        let currentPlayingTagId = null; let currentTrackIndex = 0; let currentPlaylist = []; 
        let isNfcScanning = false; let isLinkModeActive = false;

        let currentCueTracks = null; 
        let editingOriginalTagId = null;

        const SYSTEM_BG_ID = "system_bg";
        const SYSTEM_SETTINGS_ID = "system_settings"; 

        if (!("NDEFReader" in window)) safeDisplay('nfc-warning', 'block');

        loadSettings(); 

        const DB_NAME = "MusicBoxDB_v15";
        const DB_VERSION = 2;

        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = function(event) {
            db = event.target.result;
            if (!db.objectStoreNames.contains("tracks")) {
                db.createObjectStore("tracks", { keyPath: "tagId" });
            }
            if (!db.objectStoreNames.contains("stats_log")) {
                const statsStore = db.createObjectStore("stats_log", { keyPath: "id", autoIncrement: true });
                statsStore.createIndex("timestamp", "timestamp", { unique: false });
                statsStore.createIndex("type", "type", { unique: false });
            }
        };

        request.onsuccess = function(event) { 
             db = event.target.result; 
             loadTagList();
             syncSettingsFromDB(); 
             restoreLastSession();
        };
        
        // --- IMPORT MODAL LOGIC START ---
        function showImportModal(candidates, callback) {
            pendingImportCandidates = candidates;
            pendingImportCallback = callback;

            const listContainer = document.getElementById('import-list-container');
            listContainer.innerHTML = "";
            
            // UI aufbauen
            candidates.forEach((cand, index) => {
                const div = document.createElement('div');
                div.className = 'import-item';
                div.dataset.name = cand.name.toLowerCase(); // F√ºr Suchfilter
                div.dataset.age = "99"; 

                // Versuche Alter/Meta zu lesen
                let metaInfo = `${cand.fileCount} Dateien`;
                
                // Falls durch klangkiste.json Meta-Daten da sind:
                if(cand.meta && cand.meta.age_recommendation) {
                    div.dataset.age = cand.meta.age_recommendation;
                    metaInfo += ` ‚Ä¢ üë∂ Ab ${cand.meta.age_recommendation} J.`;
                }
                
                // Kombiniere Suchbegriffe f√ºr Filter
                div.dataset.search = (cand.name + " " + (cand.meta ? cand.meta.age_recommendation : "")).toLowerCase();

                div.innerHTML = `
                    <input type="checkbox" class="import-checkbox" id="chk-imp-${index}" checked>
                    <div class="import-info">
                        <div class="import-name">${cand.name}</div>
                        <div class="import-meta">${metaInfo}</div>
                    </div>
                `;
                listContainer.appendChild(div);
            });

            document.getElementById('import-modal').style.display = 'flex';
            document.getElementById('import-search').value = ""; // Reset Search
            document.getElementById('import-min-age').value = ""; // Reset Min Age
            document.getElementById('import-max-age').value = ""; // Reset Max Age
        }

        function closeImportModal() {
            document.getElementById('import-modal').style.display = 'none';
            pendingImportCandidates = [];
            pendingImportCallback = null;
            document.getElementById('bulk-folder-struct-input').value = ""; // Inputs resetten
            document.getElementById('bulk-folder-input').value = "";
        }

        function filterImportList() {
            // Hole alle Begriffe, getrennt durch Leerzeichen
            const inputVal = document.getElementById('import-search').value.toLowerCase().trim();
            const terms = inputVal.split(/\s+/).filter(t => t.length > 0);

            const minAgeInput = document.getElementById('import-min-age').value;
            const maxAgeInput = document.getElementById('import-max-age').value;

            const minAge = minAgeInput ? parseInt(minAgeInput) : 0;
            const maxAge = maxAgeInput ? parseInt(maxAgeInput) : 99;

            const items = document.querySelectorAll('.import-item');
            
            items.forEach(item => {
                const searchData = item.dataset.search || "";
                const itemAge = parseInt(item.dataset.age) || 0; // 0 = Unbekannt

                // 1. Text Check (Multi-Term Logik)
                let matchesText = true;
                
                if (terms.length > 0) {
                    for (let term of terms) {
                        if (term.startsWith('-') && term.length > 1) {
                            // NEGATIV FILTER: Wenn Begriff enthalten, dann raus!
                            const cleanTerm = term.substring(1);
                            if (searchData.includes(cleanTerm)) {
                                matchesText = false;
                                break; // Ein Ausschluss reicht
                            }
                        } else {
                            // POSITIV FILTER: Muss enthalten sein
                            if (!searchData.includes(term)) {
                                matchesText = false;
                                break; // Ein fehlender Begriff reicht
                            }
                        }
                    }
                }

                // 2. Age Check
                let matchesAge = true;
                if (itemAge > 0) {
                    if (itemAge < minAge) matchesAge = false; // Zu jung
                    if (itemAge > maxAge) matchesAge = false; // Zu alt
                }

                if(matchesText && matchesAge) item.style.display = 'flex';
                else item.style.display = 'none';
            });
        }

        // --- NEUE LOGIK F√úR DIE BUTTONS ---
        function handleSelection(mode) {
            const items = document.querySelectorAll('.import-item');
            
            items.forEach(item => {
                const chk = item.querySelector('.import-checkbox');
                if(!chk) return;

                // Pr√ºfen, ob das Element gerade durch den Filter sichtbar ist
                const isVisible = item.style.display !== 'none';

                if (mode === 'exclusive') {
                    // Dein Wunsch: 
                    // Wenn sichtbar -> HAKEN REIN
                    // Wenn unsichtbar -> HAKEN RAUS (damit alter "M√ºll" weg ist)
                    chk.checked = isVisible;
                } 
                else if (mode === 'clear_visible') {
                    // Nur die abw√§hlen, die ich gerade sehe (z.B. um einzelne auszuschlie√üen)
                    // Versteckte bleiben unber√ºhrt (falls man vorher schon was ausgew√§hlt hat)
                    if(isVisible) chk.checked = false;
                }
            });
        }

        function executeImport() {
            if(!pendingImportCallback) return;
            
            // Sammle ausgew√§hlte Kandidaten
            const selected = [];
            pendingImportCandidates.forEach((cand, index) => {
                const chk = document.getElementById(`chk-imp-${index}`);
                if(chk && chk.checked) {
                    selected.push(cand.data); // Das eigentliche Daten-Objekt
                }
            });

            if(selected.length === 0) {
                alert("Nichts ausgew√§hlt!");
                return;
            }

            const totalSize = selected.length;
            if(!confirm(`${totalSize} H√∂rb√ºcher werden importiert.\nFortfahren?`)) return;

            document.getElementById('import-modal').style.display = 'none';
            pendingImportCallback(selected); // Starte den echten Import
        }
        // --- IMPORT MODAL LOGIC END ---

        // --- NEW IMPORT LOGIC ---
        
        // 1. Ordner Struktur Import (Smart)
        async function handleFolderAlbumImport(input) {
            const files = Array.from(input.files); 
            if(files.length === 0) return;

            showStatus("Analysiere Ordner... (Bitte warten)");
            
            // Kurz warten, damit UI rendert
            await new Promise(r => setTimeout(r, 50));

            // Suche nach globaler klangkiste.json im Root oder Unterordnern f√ºr Metadaten
            let globalMetadata = [];
            const klangkisteJsonFile = files.find(f => f.name.toLowerCase().endsWith('klangkiste.json'));
            if(klangkisteJsonFile) {
                try {
                    const text = await new Promise((res, rej) => { const r = new FileReader(); r.onload = e => res(e.target.result); r.onerror = rej; r.readAsText(klangkisteJsonFile); });
                    globalMetadata = JSON.parse(text);
                } catch(e) { console.log("JSON Error", e); }
            }

            // 1. Gruppieren nach Ordnerpfad (RAM only, noch kein DB write)
            const groups = {};
            files.forEach(f => {
                const pathParts = f.webkitRelativePath ? f.webkitRelativePath.split('/') : [f.name];
                let groupKey = "";
                let folderName = "";

                if (pathParts.length > 1) {
                    pathParts.pop(); 
                    groupKey = pathParts.join('/'); 
                    folderName = pathParts[pathParts.length - 1]; 
                } else {
                    groupKey = "root_" + f.name;
                    folderName = f.name.replace(/\.[^/.]+$/, "");
                }

                if (!groups[groupKey]) {
                    groups[groupKey] = { audio: [], img: null, name: folderName };
                }

                const ext = f.name.split('.').pop().toLowerCase();
                if(['mp3', 'm4a', 'ogg', 'wav', 'flac'].includes(ext)) {
                    groups[groupKey].audio.push(f);
                } else if (['jpg', 'jpeg', 'png', 'webp'].includes(ext)) {
                    if(!groups[groupKey].img) groups[groupKey].img = f;
                }
            });

            // 2. Kandidatenliste erstellen
            const candidates = [];
            Object.keys(groups).forEach(key => {
                const g = groups[key];
                if(g.audio.length > 0) {
                    // Sortieren
                    g.audio.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true, sensitivity: 'base'}));
                    
                    // Versuche Metadaten zu finden (Match by Name)
                    let metaData = {};
                    if(globalMetadata.length > 0) {
                        // Versuch 1: Exakter Name Match
                        const found = globalMetadata.find(m => m.name === g.name);
                        if(found && found.meta) metaData = found.meta;
                    }

                    // Vorbereitetes Objekt f√ºr DB
                    const record = {
                        tagId: "folder_" + Date.now() + "_" + Math.random().toString(36).substr(2, 5),
                        name: g.name.replace(/_/g, ' '),
                        playlist: g.audio,
                        playlistFileNames: g.audio.map(f => f.name),
                        imageBlob: g.img,
                        imageFileName: g.img ? g.img.name : null,
                        cueTracks: null,
                        meta: metaData, // Hier Alter einf√ºgen
                        lastTrackIndex: 0,
                        lastTime: 0
                    };

                    candidates.push({
                        name: record.name,
                        fileCount: g.audio.length,
                        data: record, // Das volle Objekt
                        meta: metaData // F√ºr Filter
                    });
                }
            });

            if(candidates.length === 0) { alert("Keine Audio-Dateien gefunden."); return; }

            // 3. Modal anzeigen statt direkt zu speichern
            showImportModal(candidates, async (selectedItems) => {
                let count = 0;
                showStatus(`Importiere 1/${selectedItems.length}...`);
                
                for (let i = 0; i < selectedItems.length; i++) {
                    const record = selectedItems[i];
                    
                    // Jeder Eintrag wird einzeln gespeichert um RAM freizugeben
                    await new Promise((resolve) => {
                        const tx = db.transaction(["tracks"], "readwrite");
                        const store = tx.objectStore("tracks");
                        store.put(record);
                        tx.oncomplete = () => { count++; resolve(); };
                        tx.onerror = () => resolve(); 
                    });
                    
                    showStatus(`Importiere ${i+1}/${selectedItems.length}: ${record.name}`);
                }
                
                showStatus(`${count} H√∂rb√ºcher erfolgreich importiert! üéâ`);
                loadTagList();
            });
        }

        // 2. Massen Import (Flat / JSON) - UPDATED
        async function handleBulkImport(input) {
            const files = Array.from(input.files); 
            if(files.length === 0) return;

            showStatus("Analysiere Dateien...");
            await new Promise(r => setTimeout(r, 50));

            const klangkisteJsonFile = files.find(f => f.name.toLowerCase().startsWith('klangkiste') && f.name.toLowerCase().endsWith('.json'));
            
            let candidates = [];

            // A) JSON Import Logik
            if (klangkisteJsonFile) {
                try {
                    const readFileAsText = (file) => new Promise((res, rej) => { const r = new FileReader(); r.onload = e => res(e.target.result); r.onerror = rej; r.readAsText(file); });
                    const jsonText = await readFileAsText(klangkisteJsonFile);
                    const metadataEntries = JSON.parse(jsonText);
                    const findFile = (name) => files.find(f => f.name === name);

                    for (const entry of metadataEntries) {
                        const audioFiles = [];
                        if (entry.playlistFileNames) { 
                            for (const fname of entry.playlistFileNames) { 
                                const f = findFile(fname); 
                                if (f) audioFiles.push(f); 
                            } 
                        }
                        
                        if (audioFiles.length > 0) {
                            let imageBlob = null; 
                            if (entry.imageFileName) imageBlob = findFile(entry.imageFileName);
                            
                            // Cue Check
                            let cueTracks = null;
                            if(entry.playlistFileNames.length > 0) {
                                const audioBase = entry.playlistFileNames[0].replace(/\.[^/.]+$/, "");
                                const cueFile = findFile(audioBase + ".cue");
                                if (cueFile) {
                                    try { const cueText = await readFileAsText(cueFile); cueTracks = parseCueSheet(cueText); } catch(e){}
                                }
                            }

                            const record = { 
                                tagId: entry.tagId, 
                                name: entry.name, 
                                playlist: audioFiles, 
                                playlistFileNames: entry.playlistFileNames, 
                                imageBlob: imageBlob, 
                                imageFileName: entry.imageFileName, 
                                cueTracks: cueTracks, 
                                meta: entry.meta, 
                                tags: entry.tags, 
                                lastTrackIndex: 0, 
                                lastTime: 0 
                            };

                            candidates.push({
                                name: entry.name,
                                fileCount: audioFiles.length,
                                data: record,
                                meta: entry.meta || {} // Metadata f√ºr Filter nutzen
                            });
                        }
                    }
                } catch(e) {
                    alert("Fehler beim Lesen der JSON: " + e);
                    return;
                }
            } 
            // B) Normaler Flat Import (ohne JSON)
            else {
                const groups = {};
                files.forEach(f => {
                    const path = f.webkitRelativePath || f.name; 
                    const lastDot = path.lastIndexOf('.'); 
                    const basePath = lastDot > 0 ? path.substring(0, lastDot) : path;
                    
                    if (!groups[basePath]) groups[basePath] = { audio: [], img: null, cue: null, name: "" };
                    
                    const ext = f.name.split('.').pop().toLowerCase(); 
                    const fileNameOnly = f.name.substring(0, f.name.lastIndexOf('.'));
                    
                    if (!groups[basePath].name) groups[basePath].name = fileNameOnly;
                    
                    if(['mp3', 'm4a', 'ogg', 'wav', 'flac'].includes(ext)) { 
                        groups[basePath].audio.push(f); 
                    } else if (['jpg', 'jpeg', 'png', 'webp'].includes(ext)) { 
                        groups[basePath].img = f; 
                    }
                });

                Object.keys(groups).forEach(key => {
                    const g = groups[key];
                    if(g.audio.length > 0) {
                        const record = { 
                            tagId: "manual_" + Date.now() + "_" + Math.random().toString(36).substr(2, 5), 
                            name: g.name.replace(/_/g, ' '), 
                            playlist: g.audio, 
                            playlistFileNames: g.audio.map(f => f.name), 
                            imageBlob: g.img, 
                            imageFileName: g.img ? g.img.name : null, 
                            cueTracks: null, 
                            lastTrackIndex: 0, 
                            lastTime: 0 
                        };
                        candidates.push({
                            name: record.name,
                            fileCount: g.audio.length,
                            data: record,
                            meta: {}
                        });
                    }
                });
            }

            if(candidates.length === 0) { alert("Keine passenden Audio-Gruppen gefunden."); return; }

            // ZEIGE MODAL
            showImportModal(candidates, async (selectedItems) => {
                let count = 0;
                showStatus(`Importiere 1/${selectedItems.length}...`);
                
                for (let i = 0; i < selectedItems.length; i++) {
                    const record = selectedItems[i];
                    await new Promise((resolve) => {
                        const tx = db.transaction(["tracks"], "readwrite");
                        const store = tx.objectStore("tracks");
                        store.put(record);
                        tx.oncomplete = () => { count++; resolve(); };
                        tx.onerror = () => resolve();
                    });
                    showStatus(`Importiere ${i+1}/${selectedItems.length}: ${record.name}`);
                }
                showStatus(`${count} Importiert! üéâ`);
                loadTagList();
            });
        }

        // --- ENDE NEUE IMPORT LOGIK ---

        // --- PROFI STATS LOGGING ENGINE ---
        function logStatEvent(type, tagId = null, duration = 0, detailText = "") {
            if(!db) return;
            const tx = db.transaction(["stats_log"], "readwrite");
            const store = tx.objectStore("stats_log");
            
            store.add({
                timestamp: Date.now(),
                type: type, 
                tagId: tagId,
                durationSec: duration,
                details: detailText 
            });
        }

        function endSessionLog() {
            if(currentSessionStart) {
                const duration = (Date.now() - currentSessionStart) / 1000;
                if(duration > 2) { 
                    logStatEvent('stop', currentPlayingTagId, duration, `Gespielt f√ºr ${Math.round(duration)}s`);
                }
                currentSessionStart = null;
            }
        }

        // --- VOLUME LISTENER MIT DEBOUNCE ---
        let volLogTimeout = null;
        audioPlayer.addEventListener('volumechange', () => {
            if(volLogTimeout) clearTimeout(volLogTimeout);
            volLogTimeout = setTimeout(() => {
                const p = Math.round(audioPlayer.volume * 100);
                if(p > 0) logStatEvent('volume', currentPlayingTagId, 0, `Auf ${p}% ge√§ndert`);
            }, 2000); 
        });
        
        function markTrackAsCompleted(tagId) {
            if(!tagId) return;
            const tx = db.transaction(["tracks"], "readwrite");
            const store = tx.objectStore("tracks");
            store.get(tagId).onsuccess = (e) => {
                const track = e.target.result;
                if(track) {
                    track.completed = true;
                    store.put(track);
                    showStatus("üéâ Alles angeh√∂rt!");
                    logStatEvent('completed', tagId, 0, "‚úÖ Fertig geh√∂rt");
                }
            };
        }

        // --- BACKGROUND & DESIGN LOGIC ---
        function updateBgUIState() {
            const mode = document.getElementById('bg-mode-select').value;
            safeDisplay('bg-color-container', 'none');
            safeDisplay('bg-image-container', 'none');
            if (mode === 'color') safeDisplay('bg-color-container', 'block');
            else if (mode === 'image') safeDisplay('bg-image-container', 'block');
        }

        function saveBackgroundImage(input) {
            const file = input.files[0]; if(!file) return;
            const tx = db.transaction(["tracks"], "readwrite"); const store = tx.objectStore("tracks");
            store.put({tagId: SYSTEM_BG_ID, name: "System Background", imageBlob: file});
            tx.oncomplete = () => { showStatus("Hintergrund gespeichert üñºÔ∏è"); input.value = ""; applyKidsDesign(); };
        }

        function deleteBackgroundImage() {
            const tx = db.transaction(["tracks"], "readwrite"); const store = tx.objectStore("tracks");
            store.delete(SYSTEM_BG_ID);
            tx.oncomplete = () => { showStatus("Eigenes Bild gel√∂scht"); applyKidsDesign(); };
        }

        function applyKidsDesign() {
            try {
                const kidsDiv = document.getElementById('kids-mode');
                const mode = settings.bgMode || 'default';
                kidsDiv.style.backgroundImage = ''; 
                kidsDiv.style.backgroundColor = '';
                
                if (mode === 'default') { 
                    kidsDiv.style.backgroundImage = "url('assets/img/hintergrund.jpg')"; 
                    kidsDiv.style.backgroundColor = "#2c3e50"; 
                } 
                else if (mode === 'color') { kidsDiv.style.backgroundColor = settings.bgColor || '#ffffff'; }
                else if (mode === 'image') { 
                    if(!db) { kidsDiv.style.backgroundImage = "url('assets/img/hintergrund.jpg')"; return; }
                    const store = db.transaction(["tracks"], "readonly").objectStore("tracks");
                    const req = store.get(SYSTEM_BG_ID);
                    req.onsuccess = () => {
                        if(req.result && req.result.imageBlob) { const url = URL.createObjectURL(req.result.imageBlob); kidsDiv.style.backgroundImage = `url('${url}')`; } 
                        else { kidsDiv.style.backgroundImage = "url('assets/img/hintergrund.jpg')"; }
                    };
                }
            } catch(e) { console.log("Design Error", e); }
        }

        function syncSettingsFromDB() {
            const store = db.transaction(["tracks"], "readonly").objectStore("tracks");
            const req = store.get(SYSTEM_SETTINGS_ID);
            req.onsuccess = () => {
                if(req.result && req.result.data) {
                    settings = req.result.data; 
                    updateUIFromSettings();
                    
                    // Shadow List laden
                    if(settings.hiddenIDs && Array.isArray(settings.hiddenIDs)) {
                        hiddenTracks = new Set(settings.hiddenIDs);
                    }

                    if (settings.startMode === 'kids') { setTimeout(() => { goToKidsMode(); }, 100); }
                } else { saveSettings(); }
            };
        }

        function updateUIFromSettings() {
            document.getElementById('max-vol-input').value = settings.maxVolume * 100; 
            document.getElementById('vol-display').innerText = Math.round(settings.maxVolume * 100) + "%"; 
            document.getElementById('sleep-timer-input').value = settings.sleepTimerMinutes;
            document.getElementById('check-colorful').checked = settings.colorfulControls;
            document.getElementById('start-mode-input').value = settings.startMode || 'parent';
            document.getElementById('bg-mode-select').value = settings.bgMode || 'default';
            document.getElementById('bg-color-input').value = settings.bgColor || '#ffffff';
            document.getElementById('check-wakelock').checked = settings.enableWakeLock || false;
            document.getElementById('check-ecomode').checked = settings.enableEcoMode || false;
            document.getElementById('check-enable-lib').checked = settings.enableLibrary !== false; 
            document.getElementById('lib-max-age-select').value = settings.libMaxAge !== undefined ? settings.libMaxAge : "99";
            updateBgUIState(); 
        }

        function saveSettings() {
            settings.maxVolume = document.getElementById('max-vol-input').value / 100;
            applyActualVolume(); 
            settings.sleepTimerMinutes = parseInt(document.getElementById('sleep-timer-input').value);
            settings.colorfulControls = document.getElementById('check-colorful').checked;
            settings.startMode = document.getElementById('start-mode-input').value;
            settings.bgMode = document.getElementById('bg-mode-select').value;
            settings.bgColor = document.getElementById('bg-color-input').value;
            settings.enableWakeLock = document.getElementById('check-wakelock').checked;
            settings.enableEcoMode = document.getElementById('check-ecomode').checked;
            settings.enableLibrary = document.getElementById('check-enable-lib').checked;
            settings.libMaxAge = parseInt(document.getElementById('lib-max-age-select').value);
            
            // SHADOW LIST SAVE
            settings.hiddenIDs = Array.from(hiddenTracks);

            localStorage.setItem('klangkisteSettings_v16', JSON.stringify(settings));
            if(db) { const tx = db.transaction(["tracks"], "readwrite"); tx.objectStore("tracks").put({ tagId: SYSTEM_SETTINGS_ID, name: "System Settings", data: settings }); }
        }

        function loadSettings() {
            const saved = localStorage.getItem('klangkisteSettings_v16');
            if (saved) { 
                settings = JSON.parse(saved); 
                if(settings.hiddenIDs) hiddenTracks = new Set(settings.hiddenIDs);
                if (settings.startMode === 'kids') { setTimeout(() => { goToKidsMode(); }, 100); } 
            }
            updateUIFromSettings(); 
        }

        function updateSettingsUI() { const vol = document.getElementById('max-vol-input').value; document.getElementById('vol-display').innerText = vol + "%"; saveSettings(); }

        function applyActualVolume() { let visualVolume = currentKidsVolumePct * settings.maxVolume; audioPlayer.volume = Math.pow(visualVolume, 2); }
        function changeVolume(change) { currentKidsVolumePct += change; if(currentKidsVolumePct > 1.0) currentKidsVolumePct = 1.0; if(currentKidsVolumePct < 0.0) currentKidsVolumePct = 0.0; applyActualVolume(); updateVolumeUI(); }
        function updateVolumeUI() {
            let pct = currentKidsVolumePct * 100; const bar = document.getElementById('volume-bar'); bar.style.width = pct + "%";
            if(pct < 40) bar.style.backgroundColor = "var(--green-safe)"; else if (pct < 75) bar.style.backgroundColor = "var(--orange-warn)"; else bar.style.backgroundColor = "var(--red-danger)";
        }

        // --- HAUPTFUNKTION: Versucht MP3, sonst Backup ---
        function playTestTone() {
            const path = 'assets/limit.mp3';
            
            // Audio-Objekt erstellen
            const testAudio = new Audio();
            
            // Lautst√§rke berechnen (Quadratisch f√ºr nat√ºrlicheres Gef√ºhl)
            const targetVol = Math.pow(settings.maxVolume, 2);
            testAudio.volume = targetVol;

            // --- FEHLER-MANAGER ---
            testAudio.addEventListener('error', (e) => {
                const err = testAudio.error;
                let errorDetails = "";

                // Genaue Diagnose f√ºr dich
                switch (err.code) {
                    case 1: // MEDIA_ERR_ABORTED
                        errorDetails = "Abbruch durch System/User";
                        break;
                    case 2: // MEDIA_ERR_NETWORK
                        errorDetails = "Netzwerk/Cache Fehler (Service Worker inaktiv?)";
                        break;
                    case 3: // MEDIA_ERR_DECODE
                        errorDetails = "Datei besch√§digt (Dekodierfehler)";
                        break;
                    case 4: // MEDIA_ERR_SRC_NOT_SUPPORTED
                        errorDetails = "Datei nicht gefunden (404) oder Format falsch";
                        break;
                    default:
                        errorDetails = "Unbekannter Fehler Code " + err.code;
                }

                console.warn("MP3 Fehler:", errorDetails);
                
                // Meldung an User und Backup starten
                showStatus("‚ö†Ô∏è " + errorDetails + " -> Spiele Backup-Ton üö®");
                playBackupTone(targetVol);
            });

            // --- ERFOLGS-FALL ---
            testAudio.addEventListener('canplaythrough', () => {
                // Nur zur Info, dass MP3 geklappt hat
                console.log("limit.mp3 erfolgreich geladen.");
            });

            // Setze Pfad und starte
            testAudio.src = path;
            
            testAudio.play()
                .then(() => {
                    showStatus("üîä Test-Ton (MP3) l√§uft...");
                })
                .catch(e => {
                    // Dieser Block f√§ngt Fehler ab, die SOFORT beim Aufruf passieren
                    // (z.B. wenn der Browser Autoplay blockiert oder der Pfad komplett ung√ºltig ist)
                    console.error("Play-Promise Fehler:", e);
                    
                    if (e.name === "NotAllowedError") {
                        showStatus("‚ùå Wiedergabe vom Browser blockiert (Bitte interagieren)");
                    } else {
                        // Bei allen anderen Fehlern: Backup versuchen!
                        showStatus("‚ö†Ô∏è Startfehler -> Spiele Backup-Ton üö®");
                        playBackupTone(targetVol);
                    }
                });
        }

        // --- BACKUP FUNKTION (Web Audio API - funktioniert IMMER) ---
        function playBackupTone(volume) {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) {
                    alert("Kein Ton m√∂glich: Weder MP3 noch WebAudio unterst√ºtzt.");
                    return;
                }
                
                const ctx = new AudioContext();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                // Ein angenehmer Sinus-Ton (√§hnlich wie ein Testbild-Piepen)
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, ctx.currentTime); // 440 Hz (Standard Kammerton A)
                
                // Lautst√§rke setzen
                gain.gain.setValueAtTime(volume, ctx.currentTime);
                
                // Verkabeln: Oszillator -> Lautst√§rke -> Ausgang
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                // Abspielen
                osc.start();
                
                // Nach 1 Sekunde sanft ausblenden und stoppen
                const stopTime = ctx.currentTime + 1;
                gain.gain.exponentialRampToValueAtTime(0.001, stopTime);
                osc.stop(stopTime);
                
                // Aufr√§umen nach dem Ton
                setTimeout(() => {
                    ctx.close();
                }, 1200);

            } catch(e) {
                console.error("Sogar Backup gescheitert:", e);
                alert("Totalausfall Audio: " + e.message);
            }
        }

        // --- WAKE LOCK & ECO (SAFE) ---
        async function requestWakeLock() {
            if (!settings.enableWakeLock) return;
            if ('wakeLock' in navigator) { 
                try { wakeLock = await navigator.wakeLock.request('screen'); } 
                catch (err) { console.error("WakeLock failed:", err); } 
            }
            if(stubbornVideo) stubbornVideo.play().catch(e => {});
        }
        
        async function releaseWakeLock() { 
            if (wakeLock !== null) { await wakeLock.release(); wakeLock = null; } 
            if(stubbornVideo) stubbornVideo.pause(); 
        }
        
        document.addEventListener('visibilitychange', async () => { 
            if (document.visibilityState === 'visible' && settings.enableWakeLock && !isParentMode) { 
                requestWakeLock(); 
            } 
        });

        document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'hidden') { forceSaveCurrentPosition(); } });
        window.addEventListener('beforeunload', () => { forceSaveCurrentPosition(); endSessionLog(); });

        function updateEcoModeState(fromCheckbox = false) {
            const isChecked = document.getElementById('check-ecomode').checked;
            const curtain = document.getElementById('black-curtain');
            if (isChecked) { 
                window.addEventListener('deviceorientation', handleOrientation); 
                if(fromCheckbox) showStatus("Sensoren gestartet ‚úÖ"); 
            } else { 
                window.removeEventListener('deviceorientation', handleOrientation); 
                if(curtain) curtain.style.display = 'none'; 
                if(fromCheckbox) showStatus("Sensoren aus"); 
            }
            if(fromCheckbox) saveSettings();
        }
        
        function handleOrientation(event) {
            const beta = event.beta; if(beta === null) return; const isFaceDown = (beta > 140 || beta < -140);
            const curtain = document.getElementById('black-curtain');
            if(!curtain) return;
            if (isFaceDown) { 
                if (curtain.style.display !== 'block') {
                    curtain.style.display = 'block';
                    logStatEvent('eco_flip'); 
                } 
            } 
            else { if (curtain.style.display === 'block') curtain.style.display = 'none'; }
        }
        
        function requestIOSPermission() {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(response => {
                    if (response === 'granted') { alert("Sensoren aktiviert! ‚úÖ"); document.getElementById('check-ecomode').checked = true; updateEcoModeState(true); } else { alert("Zugriff verweigert ‚ùå"); }
                }).catch(console.error);
            } else { alert("Auf diesem Ger√§t nicht n√∂tig/m√∂glich."); }
        }

        // --- NFC LOGIC ---
        async function startNFC() {
            if (isNfcScanning) return; if ("NDEFReader" in window) {
                try {
                    ndef = new NDEFReader(); await ndef.scan(); isNfcScanning = true; showStatus("Scanner gestartet ‚úÖ");
                    ndef.onreading = event => {
                        const flash = document.getElementById('flash-overlay'); flash.style.opacity = "1"; setTimeout(() => flash.style.opacity = "0", 200);
                        if (isParentMode) {
                            if (isLinkModeActive) { saveTrackLink(event.serialNumber); isLinkModeActive = false; } else { showStatus("Tag erkannt: " + event.serialNumber); }
                        } else { 
                            logStatEvent('scan', null, 0, event.serialNumber); 
                            playTrackByTag(event.serialNumber); 
                        }
                    };
                } catch (error) { console.log("NFC Fehler:", error); isNfcScanning=false; }
            }
        }

        // --- PLAYBACK ---
        function playTrackByTag(tagId) {
            if (currentPlayingTagId === tagId) {
                if(audioPlayer.paused) {
                    audioPlayer.play();
                    setPlayButtonState(true);
                    startSleepTimer();
                    requestWakeLock();
                    showStatus("Fortgesetzt ‚ñ∂Ô∏è");
                    currentSessionStart = Date.now(); 
                    logStatEvent('play', tagId, 0, "Resume");
                } else {
                    showStatus("Spielt bereits üîä");
                }
                return;
            }
            
            endSessionLog();

            if(currentPlayingTagId && currentPlayingTagId !== tagId) forceSaveCurrentPosition();
            
            const tx = db.transaction(["tracks"], "readwrite");
            const store = tx.objectStore("tracks");
            
            store.get(tagId).onsuccess = (e) => {
                const track = e.target.result;
                if(track) {
                    logStatEvent('play', tagId, 0, "Start"); 

                    localStorage.setItem('lastActiveTagId', tagId);

                    track.lastPlayedTimestamp = Date.now();
                    store.put(track);

                    if(!track.playlist || track.playlist.length === 0) { showStatus("‚ö†Ô∏è Audio fehlt!"); return; }
                    document.getElementById('track-title-display').innerText = track.name;
                    const imgEl = document.getElementById('album-img'); const placeEl = document.getElementById('album-placeholder');
                    if(track.imageBlob) { imgEl.src = URL.createObjectURL(track.imageBlob); imgEl.style.display="block"; placeEl.style.display="none"; } 
                    else { imgEl.style.display="none"; placeEl.style.display="block"; }
                    
                    currentPlayingTagId = tagId; currentPlaylist = track.playlist;
                    currentCueTracks = track.cueTracks || null;
                    
                    const nextBtn = document.getElementById('btn-next-track');
                    // UPDATE: Zeige Button wenn Cues ODER wenn Playlist > 1
                    if((currentCueTracks && currentCueTracks.length > 0) || (currentPlaylist && currentPlaylist.length > 1)) { 
                        nextBtn.style.display = "flex"; 
                    } else { 
                        nextBtn.style.display = "none"; 
                    }

                    let startIndex = track.lastTrackIndex || 0; let startTime = track.lastTime || 0;
                    if(startIndex >= currentPlaylist.length) startIndex = 0;
                    
                    playPlaylistIndex(startIndex, startTime);
                    if (isParentMode) { goToKidsMode(); }
                } else { showStatus("Tag unbekannt"); }
            };
        }

        function playPlaylistIndex(index, startTime = 0) {
            if(index >= currentPlaylist.length) return;
            
            // --- REPARATUR START: Speicherleck beheben ---
            // Wenn schon eine URL existiert, diese aus dem Speicher entfernen!
            if (currentAudioUrl) {
                URL.revokeObjectURL(currentAudioUrl);
                currentAudioUrl = null;
            }
            // --- REPARATUR ENDE ---

            currentTrackIndex = index;
            const file = currentPlaylist[index];
            
            // Neue URL erstellen und merken
            currentAudioUrl = URL.createObjectURL(file);
            
            updateInfoText();
            audioPlayer.src = currentAudioUrl; // Benutze die globale Variable
            
            audioPlayer.onloadedmetadata = () => {
                if(startTime > 0 && startTime < audioPlayer.duration - 2) audioPlayer.currentTime = startTime;
                applyActualVolume(); updateVolumeUI();
                audioPlayer.play().then(() => { 
                    setPlayButtonState(true); startSleepTimer(); requestWakeLock(); 
                    currentSessionStart = Date.now(); 
                    
                    if(saveInterval) clearInterval(saveInterval);
                    saveInterval = setInterval(forceSaveCurrentPosition, 5000);

                }).catch(e => showStatus("Bereit"));
                audioPlayer.onloadedmetadata = null;
            };
        }

        function restoreLastSession() {
            // 1. Crash/Close Analyse vom letzten Mal
            const lastHeartbeat = parseInt(localStorage.getItem('stat_heartbeat') || 0);
            const lastSessionStart = parseInt(localStorage.getItem('stat_session_start') || 0);
            const now = Date.now();

            if (lastHeartbeat > 0 && lastSessionStart > 0 && (now - lastHeartbeat > 15000)) {
                const duration = (lastHeartbeat - lastSessionStart) / 1000;
                
                if (duration > 5) { // Nur wenn l√§nger als 5 Sek lief
                    // Wir mogeln diesen Eintrag nachtr√§glich in die DB mit dem ALTEN Zeitstempel
                    if(db) {
                          const tx = db.transaction(["stats_log"], "readwrite");
                          const store = tx.objectStore("stats_log");
                          store.add({
                            timestamp: lastHeartbeat, // Zeitstempel des Schlie√üens
                            type: 'app_close',        // Neuer Typ
                            tagId: localStorage.getItem('lastActiveTagId'), // Tag ID von damals
                            durationSec: duration,
                            details: `App beendet / geschlossen`
                        });
                    }
                }
                localStorage.removeItem('stat_heartbeat');
                localStorage.removeItem('stat_session_start');
            }

            // 2. Normale Wiederherstellung (Dein alter Code)
            const lastId = localStorage.getItem('lastActiveTagId');
            if(lastId) {
                const tx = db.transaction(["tracks"], "readonly");
                const store = tx.objectStore("tracks");
                store.get(lastId).onsuccess = (e) => {
                    const track = e.target.result;
                    if(track) {
                        document.getElementById('track-title-display').innerText = track.name;
                        const imgEl = document.getElementById('album-img'); 
                        const placeEl = document.getElementById('album-placeholder');
                        if(track.imageBlob) { 
                            imgEl.src = URL.createObjectURL(track.imageBlob); 
                            imgEl.style.display="block"; 
                            placeEl.style.display="none"; 
                        } else { 
                            imgEl.style.display="none"; 
                            placeEl.style.display="block"; 
                        }
                        
                        currentPlayingTagId = track.tagId;
                        currentPlaylist = track.playlist;
                        currentCueTracks = track.cueTracks || null;
                        
                        const nextBtn = document.getElementById('btn-next-track');
                        // UPDATE: Zeige Button wenn Cues ODER wenn Playlist > 1
                        if((currentCueTracks && currentCueTracks.length > 0) || (currentPlaylist && currentPlaylist.length > 1)) { 
                            nextBtn.style.display = "flex"; 
                        } else { 
                            nextBtn.style.display = "none"; 
                        }

                        let startIndex = track.lastTrackIndex || 0; 
                        let startTime = track.lastTime || 0;
                        if(startIndex >= currentPlaylist.length) startIndex = 0;
                        
                        currentTrackIndex = startIndex;
                        const file = currentPlaylist[startIndex];
                        const audioUrl = URL.createObjectURL(file);
                        updateInfoText();
                        audioPlayer.src = audioUrl;
                        audioPlayer.currentTime = startTime;
                        showStatus("Wiederhergestellt ‚Ü©Ô∏è");
                    }
                };
            }
        }

        // --- STATS VISUALIZATION LOGIC ---
        let currentStatsScope = 'day';

        window.openStats = function() {
            document.getElementById('stats-modal').style.display = 'flex';
            window.loadStats('day');
        }
        
        window.closeStats = function() {
            document.getElementById('stats-modal').style.display = 'none';
        }

        window.loadStats = function(scope) {
            currentStatsScope = scope;
            
            document.querySelectorAll('.stats-toggle-btn').forEach(b => b.classList.remove('active'));
            if(scope === 'day') document.getElementById('btn-stat-day').classList.add('active');
            if(scope === 'week') document.getElementById('btn-stat-week').classList.add('active');
            if(scope === 'all') document.getElementById('btn-stat-all').classList.add('active');

            const tx = db.transaction(["stats_log", "tracks"], "readonly");
            const logStore = tx.objectStore("stats_log");
            const trackStore = tx.objectStore("tracks");
            
            const request = logStore.getAll();
            
            request.onsuccess = (e) => {
                const logs = e.target.result;
                const now = new Date();
                let cutoff = 0;
                
                if(scope === 'day') {
                    const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
                    cutoff = startOfDay;
                } else if (scope === 'week') {
                    const startOfWeek = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000).getTime();
                    cutoff = startOfWeek;
                }
                
                const filteredLogs = logs.filter(l => l.timestamp >= cutoff);
                
                let totalSeconds = 0;
                let sessions = 0;
                const trackCounts = {};
                const timeOfDay = { 'Morgens (6-12)':0, 'Mittags (12-18)':0, 'Abends (18-24)':0, 'Nachts (0-6)':0 };

                filteredLogs.forEach(l => {
                    if(l.type === 'stop') {
                        totalSeconds += (l.durationSec || 0);
                        sessions++;
                        
                        if(l.tagId) {
                            trackCounts[l.tagId] = (trackCounts[l.tagId] || 0) + (l.durationSec || 0);
                        }

                        const hour = new Date(l.timestamp).getHours();
                        if(hour >= 6 && hour < 12) timeOfDay['Morgens (6-12)'] += l.durationSec;
                        else if(hour >= 12 && hour < 18) timeOfDay['Mittags (12-18)'] += l.durationSec;
                        else if(hour >= 18 && hour <= 23) timeOfDay['Abends (18-24)'] += l.durationSec;
                        else timeOfDay['Nachts (0-6)'] += l.durationSec;
                    }
                });

                const hours = Math.floor(totalSeconds / 3600);
                const mins = Math.floor((totalSeconds % 3600) / 60);
                document.getElementById('stat-total-time').innerText = `${hours}h ${mins}m`;
                
                const avg = sessions > 0 ? Math.round((totalSeconds / sessions) / 60) : 0;
                document.getElementById('stat-avg-session').innerText = `${avg}m`;

                const allTracksReq = trackStore.getAll();
                allTracksReq.onsuccess = (ev) => {
                    const allTracks = ev.target.result || [];
                    const completedCount = allTracks.filter(t => t.completed).length;
                    document.getElementById('stat-completed-count').innerText = completedCount;
                };

                const topListEl = document.getElementById('stats-top-tracks');
                topListEl.innerHTML = "";
                const sortedTracks = Object.keys(trackCounts).sort((a,b) => trackCounts[b] - trackCounts[a]).slice(0, 5);
                
                if(sortedTracks.length === 0) topListEl.innerHTML = "<div style='color:#777; font-style:italic;'>Keine Daten</div>";
                
                sortedTracks.forEach(tagId => {
                      const tReq = trackStore.get(tagId);
                      tReq.onsuccess = (tr) => {
                          const track = tr.target.result;
                          const name = track ? track.name : "Unbekannt";
                          const duration = Math.round(trackCounts[tagId] / 60);
                          
                          const maxVal = trackCounts[sortedTracks[0]];
                          const pct = (trackCounts[tagId] / maxVal) * 100;

                          const row = document.createElement('div');
                          row.className = 'chart-row';
                          row.innerHTML = `
                            <div class="chart-label">${name}</div>
                            <div class="chart-bar-bg"><div class="chart-bar-fill" style="width:${pct}%"></div></div>
                            <div class="chart-val">${duration}m</div>
                          `;
                          topListEl.appendChild(row);
                      }
                });

                const heatEl = document.getElementById('stats-time-heatmap');
                heatEl.innerHTML = "";
                let maxTime = 0;
                for(let k in timeOfDay) if(timeOfDay[k] > maxTime) maxTime = timeOfDay[k];
                
                for(let k in timeOfDay) {
                    if(maxTime === 0) break;
                    const val = timeOfDay[k];
                    const pct = (val / maxTime) * 100;
                    const row = document.createElement('div');
                    row.className = 'chart-row';
                    row.innerHTML = `
                        <div class="chart-label">${k}</div>
                        <div class="chart-bar-bg"><div class="chart-bar-fill" style="width:${pct}%; background:#e67e22;"></div></div>
                    `;
                    heatEl.appendChild(row);
                }
                if(maxTime === 0) heatEl.innerHTML = "<div style='color:#777; font-style:italic;'>Keine Daten</div>";

                // --- TIMELINE GENERIERUNG ---
                const tlContainer = document.getElementById('stats-timeline-list');
                tlContainer.innerHTML = "";

                const allTracksRequest = trackStore.getAll();
                
                allTracksRequest.onsuccess = (evT) => {
                    const allTracks = evT.target.result;
                    const trackMap = {};
                    allTracks.forEach(t => trackMap[t.tagId] = t.name);

                    // Sortieren: Neueste zuerst
                    const sortedLogs = filteredLogs.sort((a,b) => b.timestamp - a.timestamp).slice(0, 50); 

                    if(sortedLogs.length === 0) {
                        tlContainer.innerHTML = "<div style='color:#777; padding:10px;'>Keine Aktivit√§ten im Zeitraum.</div>";
                        return;
                    }

                    sortedLogs.forEach(log => {
                        const date = new Date(log.timestamp);
                        const timeStr = date.toLocaleTimeString('de-DE', {hour: '2-digit', minute:'2-digit', second:'2-digit'});
                        const dateStr = date.toLocaleDateString('de-DE'); 

                        let icon = "‚Ä¢";
                        let color = "#aaa";
                        let title = "Event";
                        let text = "";

                        const tName = trackMap[log.tagId] ? `<strong>${trackMap[log.tagId]}</strong>` : (log.tagId || "System");

                        switch(log.type) {
                            case 'play':
                                icon = "‚ñ∂Ô∏è"; color = "#2ecc71";
                                title = "Wiedergabe gestartet";
                                text = tName;
                                break;
                            case 'stop':
                                icon = "üõë"; color = "#e74c3c";
                                title = "Stopp / Pause";
                                const min = Math.floor((log.durationSec||0)/60);
                                const sec = Math.round((log.durationSec||0)%60);
                                text = `${tName} <br><span style="color:#fab1a0">Laufzeit: ${min}m ${sec}s</span>`;
                                break;
                            case 'scan':
                                icon = "üì°"; color = "#3498db";
                                title = "NFC Scan";
                                text = `Tag ID: ${log.details || log.tagId}`;
                                break;
                            case 'volume':
                                icon = "üîä"; color = "#f1c40f";
                                title = "Lautst√§rke";
                                text = log.details || "Angepasst";
                                break;
                            case 'seek':
                                icon = "‚è©"; color = "#9b59b6";
                                title = "Spulen / Skip";
                                text = `${tName} (${log.details})`;
                                break;
                            case 'eco_flip':
                                icon = "üôÉ"; color = "#95a5a6";
                                title = "Umdrehen (Eco)";
                                text = "Display gedimmt";
                                break;
                            case 'completed':
                                icon = "üèÜ"; color = "#fdcb6e";
                                title = "Abgeschlossen";
                                text = `${tName} komplett geh√∂rt!`;
                                break;
                            case 'control':
                                icon = "üïπÔ∏è"; color = "#dfe6e9";
                                title = "Steuerung";
                                text = `${tName} (${log.details})`;
                                break;
                            case 'app_close':
                                icon = "üö™"; color = "#7f8c8d"; // Grau
                                title = "App beendet";
                                const minC = Math.floor((log.durationSec||0)/60);
                                const secC = Math.round((log.durationSec||0)%60);
                                text = `${tName} <br><span style="color:#fab1a0">Lief davor: ${minC}m ${secC}s</span>`;
                                break;
                            default:
                                title = log.type;
                                text = log.details || "";
                        }

                        const item = document.createElement('div');
                        item.className = "timeline-item";
                        item.innerHTML = `
                            <div class="timeline-dot" style="background:${color}; border-color:${color}"></div>
                            <div class="timeline-time">${timeStr} <span style="opacity:0.5">(${dateStr})</span></div>
                            <div class="timeline-content">
                                <div style="font-weight:bold; color:${color}; margin-bottom:4px;">${icon} ${title}</div>
                                <div>${text}</div>
                            </div>
                        `;
                        tlContainer.appendChild(item);
                    });
                };
            };
        }

        // --- REST OF APP LOGIC ---

        function updateInfoText() {
            const infoEl = document.getElementById('playlist-info');
            
            // PRIORIT√ÑT: Cues -> Dateiname -> Fallback
            if (currentCueTracks) { 
                infoEl.innerText = "Kapitel laden..."; 
            } else {
                if(currentPlaylist.length > 0 && currentPlaylist[currentTrackIndex]) {
                      // Echtes File-Objekt Name holen
                      let fname = currentPlaylist[currentTrackIndex].name;
                      // ".mp3" Endung entfernen f√ºr sch√∂nere Ansicht
                      if(fname.lastIndexOf('.') > 0) fname = fname.substring(0, fname.lastIndexOf('.'));
                      
                      infoEl.innerText = fname;
                } else {
                    infoEl.innerText = "";
                }
            }
        }

        function skipToNextCueTrack() {
            // Dies ist jetzt der generische "NEXT" Button
            
            // 1. Priorit√§t: Cue Tracks (Kapitel innerhalb einer Datei)
            if(currentCueTracks && audioPlayer.src) {
                const now = audioPlayer.currentTime;
                const nextTrack = currentCueTracks.find(t => t.time > (now + 2)); 
                if(nextTrack) { 
                    audioPlayer.currentTime = nextTrack.time; 
                    showStatus("‚è© " + nextTrack.title); 
                    logStatEvent('seek', currentPlayingTagId, 0, "Kapitel: " + nextTrack.title);
                } else { showStatus("Ende erreicht"); }
                return;
            }

            // 2. Priorit√§t: Mehrere Dateien (Ordner Import) - ZUM N√ÑCHSTEN TRACK SPRINGEN
            if(currentPlaylist.length > 1) {
                if(currentTrackIndex + 1 < currentPlaylist.length) {
                    playPlaylistIndex(currentTrackIndex + 1, 0);
                    showStatus("‚è≠Ô∏è N√§chster Track");
                } else {
                    showStatus("Ende der Playlist");
                }
            }
        }

        audioPlayer.onended = () => {
            if(saveInterval) clearInterval(saveInterval);

            if(currentPlayingTagId && currentPlaylist.length > 0) {
                if(currentTrackIndex + 1 < currentPlaylist.length) {
                    playPlaylistIndex(currentTrackIndex + 1, 0);
                } else { 
                    markTrackAsCompleted(currentPlayingTagId);
                    setPlayButtonState(false); 
                    currentTrackIndex = 0; 
                    forceSaveCurrentPosition(); 
                    releaseWakeLock(); 
                    endSessionLog(); 
                }
            }
        };

        async function loadExamplesFromGitHub(event) {
            if(event) {
                event.stopPropagation();
                event.preventDefault();
            }

            const BASE_URL = "https://raw.githubusercontent.com/basecore/klangkiste/main/example/";
            
            if(!confirm("M√∂chtest du die Beispiel-H√∂rspiele (ca. 10 MB) jetzt herunterladen?")) return;

            showStatus("‚è≥ Lade Daten von GitHub...");

            try {
                const jsonResp = await fetch(BASE_URL + "klangkiste.json");
                if (!jsonResp.ok) throw new Error("JSON nicht gefunden");
                const data = await jsonResp.json();
                
                if(!db) { alert("Datenbank noch nicht bereit. Warte kurz..."); return; }

                const preparedEntries = [];

                for (const entry of data) {
                    showStatus(`üì• Lade Dateien f√ºr: ${entry.name.substring(0, 15)}...`);
                    
                    const audioBlobs = [];
                    if (entry.playlistFileNames) {
                        for (const fileName of entry.playlistFileNames) {
                            const resp = await fetch(BASE_URL + encodeURIComponent(fileName));
                            if (resp.ok) {
                                const blob = await resp.blob();
                                audioBlobs.push(new File([blob], fileName, { type: "audio/mp3" }));
                            }
                        }
                    }
                    if (audioBlobs.length === 0) continue;

                    let imageBlob = null;
                    if (entry.imageFileName) {
                        const resp = await fetch(BASE_URL + encodeURIComponent(entry.imageFileName));
                        if (resp.ok) {
                            const blob = await resp.blob();
                            imageBlob = new File([blob], entry.imageFileName, { type: "image/png" });
                        }
                    }

                    preparedEntries.push({
                        tagId: entry.tagId,
                        name: entry.name,
                        playlist: audioBlobs,
                        playlistFileNames: entry.playlistFileNames,
                        imageBlob: imageBlob,
                        imageFileName: entry.imageFileName,
                        meta: entry.meta || {},
                        tags: entry.tags || [],
                        filter_age: entry.filter_age || 0,
                        lastTrackIndex: 0, 
                        lastTime: 0,
                        completed: false
                    });
                }

                if(preparedEntries.length === 0) { alert("Keine Daten geladen."); return; }

                showStatus("üíæ Speichere in Datenbank...");
                const tx = db.transaction(["tracks"], "readwrite");
                const store = tx.objectStore("tracks");

                preparedEntries.forEach(item => {
                    store.put(item);
                });

                tx.oncomplete = () => {
                    showStatus("‚úÖ Fertig!");
                    loadTagList(); 
                    alert(`Erfolg! ${preparedEntries.length} H√∂rspiele installiert.`);
                };
                
                tx.onerror = (e) => alert("DB Fehler: " + e.target.error);

            } catch (e) {
                console.error(e);
                alert("Download Fehler: " + e.message);
                showStatus("Fehler ‚ùå");
            }
        }

        async function smartRelinkFiles(input) {
            const files = Array.from(input.files); 
            if(files.length === 0) return;
            
            // 1. Erstmal alle Tracks aus der DB holen
            showStatus("Lade Datenbank f√ºr Analyse...");
            const allTracks = await new Promise((resolve) => {
                const tx = db.transaction(["tracks"], "readonly");
                tx.objectStore("tracks").getAll().onsuccess = (e) => resolve(e.target.result);
            });

            let fixedCount = 0;
            const total = allTracks.length;

            // 2. Schleife durchlaufen (asynchron, damit UI nicht einfriert)
            for (let i = 0; i < total; i++) {
                const record = allTracks[i];
                
                // UI Update: Zeige Fortschritt an
                showStatus(`Pr√ºfe ${i + 1} / ${total}: ${record.name.substring(0, 15)}...`);
                
                // WICHTIG: Kurze Pause, damit der Browser den Text zeichnen kann
                await new Promise(r => setTimeout(r, 0));

                if(record.tagId === SYSTEM_BG_ID || record.tagId === SYSTEM_SETTINGS_ID) continue;

                let changed = false;
                
                // Audio Files suchen & verkn√ºpfen
                if (record.playlistFileNames && (!record.playlist || record.playlist.length === 0)) {
                    const newPlaylist = [];
                    record.playlistFileNames.forEach(name => {
                        const f = files.find(x => x.name === name);
                        if(f) newPlaylist.push(f);
                    });
                    if(newPlaylist.length > 0) {
                        record.playlist = newPlaylist;
                        changed = true;
                    }
                }
                
                // Cover Bild suchen & verkn√ºpfen
                if (record.imageFileName && !record.imageBlob) {
                    const img = files.find(x => x.name === record.imageFileName);
                    if(img) {
                        record.imageBlob = img;
                        changed = true;
                    }
                }

                // Wenn etwas repariert wurde, speichern wir diesen EINEN Eintrag
                if(changed) {
                    await new Promise((resolve) => {
                        const tx = db.transaction(["tracks"], "readwrite");
                        const store = tx.objectStore("tracks");
                        store.put(record);
                        tx.oncomplete = () => resolve();
                        tx.onerror = () => resolve(); // Fehler ignorieren und weitermachen
                    });
                    fixedCount++;
                }
            }

            showStatus(`${fixedCount} Eintr√§ge erfolgreich repariert! üéâ`); 
            loadTagList(); 
            input.value = "";
        }

        function togglePlay() { 
            if (audioPlayer.paused) { 
                if(audioPlayer.src) { 
                    audioPlayer.play(); setPlayButtonState(true); startSleepTimer(); requestWakeLock(); 
                    currentSessionStart = Date.now(); 
                    logStatEvent('play', currentPlayingTagId, 0, "Button");
                } 
                else { showStatus("Tag?"); } 
            } else { 
                if(saveInterval) clearInterval(saveInterval);
                audioPlayer.pause(); 
                setPlayButtonState(false); 
                stopSleepTimer(); 
                releaseWakeLock(); 
                forceSaveCurrentPosition();
                endSessionLog(); 
            } 
        }
        function restartPlaylist() { 
            if(currentPlayingTagId) { 
                showStatus("Start..."); 
                playPlaylistIndex(0, 0); 
                logStatEvent('control', currentPlayingTagId, 0, "Reset");
            } 
        }
        function skipForward() { 
            if(audioPlayer.src) { 
                audioPlayer.currentTime += 30; showStatus("+30 Sek"); 
                logStatEvent('seek', currentPlayingTagId, 0, "‚è© +30 Sek");
            } 
        }
        function skipBack() { 
            if(audioPlayer.src) { 
                audioPlayer.currentTime -= 30; showStatus("-30 Sek"); 
                logStatEvent('seek', currentPlayingTagId, 0, "‚è™ -30 Sek");
            } 
        }

        function setPlayButtonState(isPlaying) {
            const btn = document.getElementById('btn-play-main');
            if (isPlaying) { btn.style.backgroundColor = "var(--red-danger)"; btn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>'; } 
            else { btn.style.backgroundColor = "var(--green-safe)"; btn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>'; }
        }

        function forceSaveCurrentPosition() {
            if(!currentPlayingTagId) return;
            localStorage.setItem('lastActiveTagId', currentPlayingTagId);

            // --- NEU: Herzschlag f√ºr Statistik (App-Crash/Close Erkennung) ---
            localStorage.setItem('stat_heartbeat', Date.now());
            if(currentSessionStart) localStorage.setItem('stat_session_start', currentSessionStart);
            // -----------------------------------------------------------------
            
            const pos = audioPlayer.currentTime; 
            const tx = db.transaction(["tracks"], "readwrite"); 
            const store = tx.objectStore("tracks"); 
            const getReq = store.get(currentPlayingTagId);
            getReq.onsuccess = function() { 
                const record = getReq.result; 
                if(record) { 
                    record.lastTrackIndex = currentTrackIndex; 
                    record.lastTime = pos; 
                    store.put(record); 
                } 
            };
        }

        function startSleepTimer() {
            if(sleepTimerId) clearTimeout(sleepTimerId); document.getElementById('sleep-indicator').style.display = 'none';
            if(settings.sleepTimerMinutes > 0 && !audioPlayer.paused) {
                document.getElementById('sleep-indicator').style.display = 'block'; document.getElementById('sleep-countdown').innerText = settings.sleepTimerMinutes + " min";
                sleepTimerId = setTimeout(() => { fadeOutAndStop(); }, settings.sleepTimerMinutes * 60 * 1000);
            }
        }
        function stopSleepTimer() { if(sleepTimerId) clearTimeout(sleepTimerId); document.getElementById('sleep-indicator').style.display = 'none'; }
        function fadeOutAndStop() { 
            let vol = audioPlayer.volume; 
            const fade = setInterval(() => { 
                if(vol > 0.05) { vol -= 0.05; audioPlayer.volume = vol; } 
                else { 
                    clearInterval(fade); 
                    if(saveInterval) clearInterval(saveInterval);
                    audioPlayer.pause(); 
                    setPlayButtonState(false); 
                    forceSaveCurrentPosition(); 
                    applyActualVolume(); 
                    showStatus("Gute Nacht üò¥"); 
                    endSessionLog();
                } 
            }, 200); 
        }
        function clearDatabase() { 
            if(confirm("L√∂schen?")) { 
                db.close(); 
                indexedDB.deleteDatabase(DB_NAME); 
                localStorage.removeItem('lastActiveTagId');
                location.reload(); 
            } 
        }
        function showStatus(msg) { const el = document.getElementById('status-msg'); el.innerText = msg; el.style.display = 'block'; setTimeout(() => { el.style.display = 'none'; }, 3000); }
        function formatTime(s) { const minutes = Math.floor(s / 60); const seconds = Math.floor(s % 60); return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; }
        function applyButtonColors() {
            try {
                const volDown = document.getElementById('btn-vol-down'); const volUp = document.getElementById('btn-vol-up'); const back = document.getElementById('btn-reset'); const skip = document.getElementById('btn-skip'); const next = document.getElementById('btn-next-track');
                const rewind = document.getElementById('btn-rewind'); 

                if (settings && settings.colorfulControls) { 
                    volDown.classList.add('btn-colorful-vol-down'); volUp.classList.add('btn-colorful-vol-up'); back.classList.add('btn-colorful-back'); skip.classList.add('btn-colorful-skip'); next.classList.add('btn-colorful-next');
                    rewind.classList.add('btn-colorful-rewind');
                } else { 
                    volDown.classList.remove('btn-colorful-vol-down'); volUp.classList.remove('btn-colorful-vol-up'); back.classList.remove('btn-colorful-back'); skip.classList.remove('btn-colorful-skip'); next.classList.remove('btn-colorful-next');
                    rewind.classList.remove('btn-colorful-rewind');
                }
            } catch(e) {}
        }

        audioPlayer.addEventListener('timeupdate', () => {
            if(isNaN(audioPlayer.duration)) { document.getElementById('time-text').innerText = "--:--"; return; }
            const current = audioPlayer.currentTime; const total = audioPlayer.duration; const pct = (current/total)*100;
            document.getElementById('time-progress').style.width = pct + "%";
            document.getElementById('time-text').innerText = showRemainingTime ? "-" + formatTime(total-current) : formatTime(current);
            
            if(currentCueTracks) {
                let currentChapterName = "";
                for(let i=currentCueTracks.length-1; i>=0; i--) {
                    if(current >= currentCueTracks[i].time) { currentChapterName = currentCueTracks[i].title; break; }
                }
                if(currentChapterName) document.getElementById('playlist-info').innerText = currentChapterName;
            }
        });

        function toggleTimeDisplayMode() { showRemainingTime = !showRemainingTime; updateTimeDisplay(); }
        document.body.addEventListener('click', async () => { if(!ndef && "NDEFReader" in window) { try { await startNFC(); } catch(e) {} } }, { once: true });

        function goToKidsMode() {
            if(isProcessingDatabase) {
                showStatus("‚ö†Ô∏è Bitte warten! Datenbank arbeitet noch...");
                return;
            }

            try {
                safeDisplay('parent-mode', 'none');
                safeDisplay('kids-mode', 'flex'); 

                isParentMode = false;
                applyKidsDesign(); 
                applyButtonColors();

                if(settings.enableLibrary !== false) {
                      document.getElementById('btn-open-lib').style.display = 'flex';
                } else {
                      document.getElementById('btn-open-lib').style.display = 'none';
                }

                enterFullscreenSafe();

                if(settings.enableEcoMode) updateEcoModeState(false);
                
                requestWakeLock();
                startNFC().catch(err => console.log("NFC Error", err));

            } catch(e) {
                alert("Fehler beim Starten: " + e);
                safeDisplay('kids-mode', 'none');
                safeDisplay('parent-mode', 'flex');
            }
        }

        function enterFullscreenSafe() {
            const elem = document.documentElement;
            const requestFS = () => {
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch((e) => console.log("FS blocked", e));
                } else if (elem.webkitRequestFullscreen) { 
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { 
                    elem.msRequestFullscreen();
                }
            };
            requestFS();
            const userInteractionHandler = () => {
                if (!document.fullscreenElement && !document.webkitFullscreenElement) { requestFS(); }
            };
            document.addEventListener('click', userInteractionHandler, { once: true });
            document.addEventListener('touchstart', userInteractionHandler, { once: true, passive: true });
        }
        
        document.getElementById('kids-mode').addEventListener('touchstart', () => {
            if(!isParentMode) requestWakeLock();
        }, {passive: true});

        function handleSecretSwitch() {
            clickCount++; 
            setTimeout(() => { clickCount = 0; }, 2000); 
            
            if (clickCount >= 5) {
                // 1. Haupt-Modus umschalten
                safeDisplay('kids-mode', 'none');
                safeDisplay('parent-mode', 'flex');
                
                // 2. NEU: St√∂rende Fenster zwangsweise schlie√üen
                // Damit die Bibliothek nicht den Admin-Bereich verdeckt
                if(typeof closeLibrary === "function") {
                    closeLibrary(); 
                } else {
                    document.getElementById('library-mode').style.display = 'none';
                }
                
                // Auch andere eventuell offene Fenster schlie√üen
                document.getElementById('lib-info-modal').style.display = 'none';
                document.getElementById('stats-modal').style.display = 'none';

                // 3. Cleanup & System
                isParentMode = true; 
                clickCount = 0; 
                releaseWakeLock(); 
                endSessionLog();
                
                if (document.exitFullscreen && document.fullscreenElement) { 
                    document.exitFullscreen().catch((e) => {}); 
                }
            }
        }
        function autoFillName() {
            const input = document.getElementById('audio-input'); const nameField = document.getElementById('track-name');
            if (input.files.length > 0 && nameField.value === "") {
                let name = input.files[0].name; if(name.lastIndexOf('.') > 0) { name = name.substring(0, name.lastIndexOf('.')); } nameField.value = name;
            }
        }

        // --- SPEICHERN ---
        function saveTrackLink(tagId) {
            if(isProcessingDatabase) return; 

            const audioInput = document.getElementById('audio-input');
            const imgInput = document.getElementById('img-input');
            const cueInput = document.getElementById('cue-input');
            const name = document.getElementById('track-name').value;
            const metaDesc = document.getElementById('meta-desc').value;
            const metaAge = document.getElementById('meta-age').value;
            const metaGenre = document.getElementById('meta-genre').value;
            const metaRuntime = document.getElementById('meta-runtime').value;
            const isHidden = document.getElementById('track-hidden-lib').checked;

            const finalize = (oldRecord = null, newCueTracks = null) => {
                let finalAudio = audioInput.files.length > 0 ? Array.from(audioInput.files) : (oldRecord ? oldRecord.playlist : []);
                let finalFileNames = audioInput.files.length > 0 ? Array.from(audioInput.files).map(f=>f.name) : (oldRecord ? oldRecord.playlistFileNames : []);
                let finalImg = imgInput.files.length > 0 ? imgInput.files[0] : (oldRecord ? oldRecord.imageBlob : null);
                let finalImgName = imgInput.files.length > 0 ? imgInput.files[0].name : (oldRecord ? oldRecord.imageFileName : null);
                let finalCue = newCueTracks ? newCueTracks : (oldRecord ? oldRecord.cueTracks : null);

                if(finalAudio.length === 0) { alert("Kein Audio vorhanden!"); return; }

                const metaObj = {
                    description: metaDesc,
                    age_recommendation: metaAge ? parseInt(metaAge) : 0,
                    genre: metaGenre,
                    runtime: metaRuntime ? parseInt(metaRuntime) : 0
                };

                const record = { 
                    tagId: tagId, 
                    name: name, 
                    playlist: finalAudio, 
                    playlistFileNames: finalFileNames, 
                    imageBlob: finalImg, 
                    imageFileName: finalImgName, 
                    cueTracks: finalCue, 
                    meta: metaObj, 
                    hiddenInLib: isHidden, // Keep in DB for backup
                    lastTrackIndex: oldRecord ? oldRecord.lastTrackIndex : 0, 
                    lastTime: oldRecord ? oldRecord.lastTime : 0 
                };

                const tx = db.transaction(["tracks"], "readwrite"); 
                const store = tx.objectStore("tracks");
                store.put(record);

                if (editingOriginalTagId && editingOriginalTagId !== tagId) {
                    store.delete(editingOriginalTagId);
                    showStatus("Tag gewechselt & Update!");
                } else {
                    showStatus("Gespeichert!");
                }
                tx.oncomplete = () => { 
                    // Update Shadow List for new entry
                    if(isHidden) hiddenTracks.add(tagId);
                    else hiddenTracks.delete(tagId);
                    saveSettings();

                    cancelEdit(); 
                    loadTagList(); 
                };
            };

            const cueFile = cueInput.files[0];
            const processCueAndSave = (oldRecord) => {
                if(cueFile) {
                    const reader = new FileReader(); 
                    reader.onload = (e) => { const parsedTracks = parseCueSheet(e.target.result); finalize(oldRecord, parsedTracks); }; 
                    reader.readAsText(cueFile);
                } else { finalize(oldRecord, null); }
            };

            if (editingOriginalTagId) {
                const store = db.transaction(["tracks"], "readonly").objectStore("tracks");
                store.get(editingOriginalTagId).onsuccess = (e) => { processCueAndSave(e.target.result); };
            } else {
                if(audioInput.files.length === 0) { alert("Bitte Audio w√§hlen!"); return; }
                processCueAndSave(null);
            }
        }

        // --- ADMIN HELPERS ---
        function activateLinkMode() {
            const n = document.getElementById('track-name').value;
            const hasAudio = document.getElementById('audio-input').files.length > 0;
            if(!editingOriginalTagId && !hasAudio) { alert("Bitte Audio w√§hlen!"); return; }
            if(n === "") { alert("Bitte Name eingeben!"); return; }
            isLinkModeActive = true; document.getElementById('scan-status').innerText = ">>> FIGUR JETZT AUFLEGEN <<<";
            if (!isNfcScanning) startNFC();
        }
        function saveManualTrack() {
            const n = document.getElementById('track-name').value;
            const hasAudio = document.getElementById('audio-input').files.length > 0;
            if(!editingOriginalTagId && !hasAudio) { alert("Bitte Audio w√§hlen!"); return; }
            if(n === "") { alert("Bitte Name eingeben!"); return; }
            const targetId = editingOriginalTagId ? editingOriginalTagId : "manual_" + Date.now();
            saveTrackLink(targetId);
        }
        function loadTagForEdit(id) {
            const store = db.transaction(["tracks"], "readonly").objectStore("tracks");
            store.get(id).onsuccess = (e) => {
                const r = e.target.result;
                if(r) {
                    editingOriginalTagId = id;
                    document.getElementById('track-name').value = r.name;
                    if(r.meta) {
                        document.getElementById('meta-desc').value = r.meta.description || "";
                        document.getElementById('meta-age').value = r.meta.age_recommendation || "";
                        document.getElementById('meta-genre').value = r.meta.genre || "H√∂rspiel";
                        document.getElementById('meta-runtime').value = r.meta.runtime || "";
                    } else {
                        document.getElementById('meta-desc').value = "";
                        document.getElementById('meta-age').value = "";
                        document.getElementById('meta-genre').value = "H√∂rspiel";
                        document.getElementById('meta-runtime').value = "";
                    }
                    
                    // Check via Shadow List AND DB
                    const isHidden = hiddenTracks.has(id) || r.hiddenInLib === true;
                    document.getElementById('track-hidden-lib').checked = isHidden;
                    
                    document.getElementById('form-title').innerText = "‚úèÔ∏è Bearbeiten: " + r.name;
                    document.getElementById('form-title').style.color = "#3498db";
                    document.getElementById('btn-save-tag').innerText = "Speichern & Neuer Tag (Move)";
                    document.getElementById('btn-save-manual').innerText = "üíæ Speichern (Update)";
                    document.getElementById('btn-cancel-edit').style.display = "inline-block";
                    if (r.playlistFileNames && r.playlistFileNames.length > 0) {
                        const fileListStr = r.playlistFileNames.join(', ');
                        document.getElementById('audio-info').innerText = fileListStr;
                        document.getElementById('audio-info').title = fileListStr;
                    } else { document.getElementById('audio-info').innerText = "Keine Audio-Datei"; }
                    document.getElementById('cue-info').innerText = r.cueTracks ? "Kapiteldaten vorhanden" : "Keine";
                    document.getElementById('img-info').innerText = r.imageFileName ? r.imageFileName : "Standard";
                    
                    const card = document.getElementById('scan-card');
                    const container = document.getElementById('parent-mode');
                    card.classList.add("editing-highlight");
                    card.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    setTimeout(() => { if(container) { container.scrollTo({ top: card.offsetTop - 20, behavior: 'smooth' }); } }, 100);
                }
            };
        }
        function cancelEdit() {
            editingOriginalTagId = null;
            document.getElementById('track-name').value = "";
            document.getElementById('audio-input').value = "";
            document.getElementById('cue-input').value = "";
            document.getElementById('img-input').value = "";
            document.getElementById('meta-desc').value = "";
            document.getElementById('meta-age').value = "";
            document.getElementById('meta-runtime').value = "";
            document.getElementById('audio-info').innerText = "";
            document.getElementById('cue-info').innerText = "";
            document.getElementById('img-info').innerText = "";
            document.getElementById('track-hidden-lib').checked = false;

            document.getElementById('form-title').innerText = "üéµ Tag bearbeiten / anlernen";
            document.getElementById('form-title').style.color = "#74b9ff";
            document.getElementById('btn-save-tag').innerText = "üì° Tag scannen & speichern";
            document.getElementById('btn-save-manual').innerText = "üíæ Ohne NFC speichern";
            document.getElementById('btn-cancel-edit').style.display = "none";
            document.getElementById('scan-card').classList.remove("editing-highlight");
            document.getElementById('scan-status').innerText = "";
        }

        // --- ADMIN VIEW TOGGLE (LIST/GRID) ---
        function setAdminView(mode) {
            if(isProcessingDatabase) return;
            const btnGrid = document.getElementById('btn-view-grid');
            const btnList = document.getElementById('btn-view-list');
            
            if(mode === 'grid') {
                adminListView = false;
                btnGrid.classList.add('active'); btnList.classList.remove('active');
            } else {
                adminListView = true;
                btnGrid.classList.remove('active'); btnList.classList.add('active');
            }
            loadTagList();
        }
        
        // --- MASSEN-STEUERUNG (SHADOW LIST MODE - ULTRA FAST) ---
        function setAllLibraryVisibility(isHidden) {
            if(isProcessingDatabase) return;

            const msgHide = "Alle H√∂rb√ºcher verstecken?";
            const msgShow = "Alle H√∂rb√ºcher anzeigen?";
            if(!confirm(isHidden ? msgHide : msgShow)) return;

            showStatus("Verarbeite... üöÄ");
            
            // Nur IDs holen (sehr schnell)
            const tx = db.transaction(["tracks"], "readonly");
            const store = tx.objectStore("tracks");
            
            store.getAllKeys().onsuccess = (e) => {
                const keys = e.target.result;
                
                keys.forEach(k => {
                    if(k !== SYSTEM_BG_ID && k !== SYSTEM_SETTINGS_ID) {
                        if(isHidden) hiddenTracks.add(k);
                        else hiddenTracks.delete(k);
                    }
                });
                
                saveSettings(); // Speichert die neue Liste
                loadTagList(); // UI Update
                showStatus("Fertig! ‚úÖ");
            };
        }

        function toggleTrackVisibility(id) {
            if(isProcessingDatabase) return;
            
            // Toggle im RAM
            if(hiddenTracks.has(id)) {
                hiddenTracks.delete(id);
                showStatus("Sichtbar üëÅÔ∏è");
            } else {
                hiddenTracks.add(id);
                showStatus("Versteckt üö´");
            }
            
            saveSettings(); // Persistieren

            // UI Update (DOM Manipulation)
            const btn = document.getElementById(`btn-vis-${id}`);
            const badge = document.getElementById(`badge-${id}`);
            const isHidden = hiddenTracks.has(id);

            if(isHidden) {
                if(btn) { btn.innerText = "üö´"; btn.style.backgroundColor = "#555"; btn.title = "Ist versteckt (Klick zum Anzeigen)"; }
                if(badge) { badge.style.display = "flex"; }
            } else {
                if(btn) { btn.innerText = "üëÅÔ∏è"; btn.style.backgroundColor = "#f39c12"; btn.title = "Ist sichtbar (Klick zum Verstecken)"; }
                if(badge) { badge.style.display = "none"; }
            }
        }

        function loadTagList() {
            const container = document.getElementById('tag-list-container'); 
            if(!container) return; 
            
            if(adminListView) container.className = 'admin-list';
            else container.className = 'admin-grid';

            container.innerHTML = '<div style="text-align:center; color:#ccc; padding:20px;">Lade Eintr√§ge...</div>';
            
            const tx = db.transaction(["tracks"], "readonly"); 
            const store = tx.objectStore("tracks");
            const tracks = [];

            // --- REPARATUR: Cursor statt getAll() um Speicher zu sparen ---
            const request = store.openCursor();

            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    // Wir laden nur das N√∂tigste in das Array, NICHT die MP3s (playlist)
                    const t = cursor.value;
                    // Erstelle ein "leichtes" Objekt f√ºr die Anzeige
                    const lightTrack = {
                        tagId: t.tagId,
                        name: t.name,
                        imageBlob: t.imageBlob, // Bilder sind okay, MP3s sind das Problem
                        meta: t.meta,
                        completed: t.completed,
                        hiddenInLib: t.hiddenInLib
                        // Playlist lassen wir hier weg!
                    };
                    tracks.push(lightTrack);
                    cursor.continue();
                } else {
                    // Cursor ist fertig, jetzt rendern wir
                    renderAdminList(tracks, container);
                }
            };
        }

        // Neue Hilfsfunktion zum Rendern (Ausgelagert aus dem alten loadTagList)
        function renderAdminList(tracks, container) {
            let htmlBuffer = "";
            tracks.sort((a, b) => a.name.localeCompare(b.name, 'de', { sensitivity: 'base' }));

            tracks.forEach(track => {
                if(track.tagId !== "system_bg" && track.tagId !== "system_settings") {
                    
                    const isHidden = hiddenTracks.has(track.tagId);
                    const visIcon = isHidden ? "üö´" : "üëÅÔ∏è";
                    const visTitle = isHidden ? "Ist versteckt" : "Ist sichtbar";
                    const visBtnColor = isHidden ? "#555" : "#f39c12";
                    
                    if(adminListView) {
                        // LIST VIEW
                        let iconHtml = `<div class="list-icon">üéµ</div>`;
                        if (track.imageBlob) {
                            const url = URL.createObjectURL(track.imageBlob);
                            // Hier revoken wir nicht sofort, da Admin Men√º selten offen ist, 
                            // aber besser w√§re es auch hier activeCoverUrls zu nutzen.
                            iconHtml = `<img src="${url}" class="list-img-small" loading="lazy">`;
                        }

                        htmlBuffer += `
                            <div class="admin-list-row">
                                ${iconHtml}
                                <div class="list-info">
                                    <div class="list-name">${track.name}</div>
                                    <div class="list-meta">ID: ${track.tagId}</div>
                                </div>
                                <div class="admin-actions">
                                    <button class="btn-mini edit" onclick="loadTagForEdit('${track.tagId}')">‚úèÔ∏è</button>
                                    <button id="btn-vis-${track.tagId}" class="btn-mini vis" style="background-color:${visBtnColor};" onclick="toggleTrackVisibility('${track.tagId}')">${visIcon}</button>
                                    <button class="btn-mini del" onclick="deleteTrack('${track.tagId}')">üóë</button>
                                </div>
                            </div>
                        `;
                    } else {
                        // GRID VIEW (Dein alter Code, hier nur gek√ºrzt dargestellt)
                        let imgHtml = `<div style="font-size:30px;">üéµ</div>`;
                        if (track.imageBlob) {
                            const url = URL.createObjectURL(track.imageBlob);
                            imgHtml = `<img src="${url}" class="admin-cover-img" loading="lazy">`;
                        }
                        
                        let completedBadge = track.completed ? `<div class="completed-badge">‚úÖ</div>` : "";
                        const hiddenBadgeStyle = isHidden ? "display:flex;" : "display:none;";
                        const hiddenBadge = `<div id="badge-${track.tagId}" style="${hiddenBadgeStyle} position:absolute; top:5px; left:5px; background:rgba(255,255,255,0.95); color:black; border-radius:50%; width:28px; height:28px; justify-content:center; align-items:center; z-index:10; font-size:16px; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">üö´</div>`;

                        htmlBuffer += `
                            <div class="admin-card">
                                <div class="admin-cover-wrap">
                                    ${imgHtml} ${completedBadge} ${hiddenBadge}
                                </div>
                                <div class="admin-card-body">
                                    <div class="admin-card-title">${track.name}</div>
                                    <div class="admin-actions">
                                        <button class="btn-mini edit" onclick="loadTagForEdit('${track.tagId}')">‚úèÔ∏è</button>
                                        <button id="btn-vis-${track.tagId}" class="btn-mini vis" style="background-color:${visBtnColor};" onclick="toggleTrackVisibility('${track.tagId}')">${visIcon}</button>
                                        <button class="btn-mini play" onclick="playTrackByTag('${track.tagId}')">‚ñ∂</button>
                                        <button class="btn-mini del" onclick="deleteTrack('${track.tagId}')">üóë</button>
                                    </div>
                                </div>
                            </div>`;
                    }
                } 
            });
            container.innerHTML = htmlBuffer;
        }
        function deleteTrack(id) { 
            if(isProcessingDatabase) return;
            if(confirm("Wirklich l√∂schen?")) { 
                const tx = db.transaction(["tracks"], "readwrite"); 
                tx.objectStore("tracks").delete(id); 
                tx.oncomplete = () => {
                    hiddenTracks.delete(id); // Auch aus Shadow List entfernen
                    saveSettings();
                    loadTagList(); 
                };
            } 
        }

        // --- BULK IMPORT & EXPORT ---
        async function exportKlangkisteJson() {
            showStatus("Erstelle Full-Backup...");
            
            try {
                const tx = db.transaction(["tracks", "stats_log"], "readonly");
                const trackStore = tx.objectStore("tracks");
                const statsStore = tx.objectStore("stats_log");

                // 1. Hole alle Tracks & Einstellungen
                const allTracksReq = trackStore.getAll();
                const allStatsReq = statsStore.getAll();

                // Wir warten, bis beide Anfragen fertig sind
                const [tracks, stats] = await new Promise((resolve, reject) => {
                    let tracksResult = null;
                    let statsResult = null;
                    let finishedCount = 0;

                    const checkDone = () => {
                        finishedCount++;
                        if (finishedCount === 2) resolve([tracksResult, statsResult]);
                    };

                    allTracksReq.onsuccess = (e) => { tracksResult = e.target.result; checkDone(); };
                    allStatsReq.onsuccess = (e) => { statsResult = e.target.result; checkDone(); };
                    
                    allTracksReq.onerror = reject;
                    allStatsReq.onerror = reject;
                });

                // 2. Daten sortieren und aufbereiten
                const exportData = {
                    type: "FULL_BACKUP_V1",
                    timestamp: Date.now(),
                    systemSettings: {}, // Hier landen die globalen Einstellungen
                    tracks: [],
                    stats: stats || []
                };

                tracks.forEach(t => {
                    if (t.tagId === SYSTEM_SETTINGS_ID) {
                        // Globale Einstellungen (Alter, Filter, Volume etc.)
                        exportData.systemSettings = t.data;
                    } else if (t.tagId === SYSTEM_BG_ID) {
                        // Hintergrundbild ignorieren wir im JSON (zu gro√ü), 
                        // oder wir m√ºssten es Base64 codieren (komplex).
                        // Besser: Ignorieren.
                    } else {
                        // Ein echtes H√∂rbuch - ALLES speichern
                        exportData.tracks.push({
                            tagId: t.tagId,
                            name: t.name,
                            playlistFileNames: t.playlistFileNames || [],
                            imageFileName: t.imageFileName || null,
                            meta: t.meta || {},
                            tags: t.tags || [],
                            filter_age: t.filter_age || 0,
                            // --- NEUE FELDER ---
                            lastTrackIndex: t.lastTrackIndex || 0,
                            lastTime: t.lastTime || 0,            // Zeitstempel
                            completed: t.completed || false,      // Fertig geh√∂rt?
                            hiddenInLib: t.hiddenInLib || false,  // Versteckt?
                            lastPlayedTimestamp: t.lastPlayedTimestamp || 0 // Zuletzt geh√∂rt Sortierung
                        });
                    }
                });

                // 3. Download starten
                const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: "application/json"});
                const a = document.createElement('a');
                const dateStr = new Date().toISOString().slice(0,10);
                a.href = URL.createObjectURL(blob);
                a.download = `klangkiste_full_backup_${dateStr}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                showStatus("Full-Backup erstellt! ‚úÖ");

            } catch (e) {
                console.error(e);
                alert("Export Fehler: " + e.message);
            }
        }
        async function importKlangkisteJson(input) {
            const file = input.files[0]; if(!file) return; 
            showStatus("Analysiere Backup...");
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const rawData = JSON.parse(e.target.result);
                    let tracksToImport = [];
                    let statsToImport = [];
                    let settingsToImport = null;

                    // A) Ist es das neue FULL BACKUP?
                    if (rawData.type && rawData.type.startsWith("FULL_BACKUP")) {
                        console.log("Full Backup erkannt!");
                        tracksToImport = rawData.tracks || [];
                        statsToImport = rawData.stats || [];
                        settingsToImport = rawData.systemSettings || null;
                    } 
                    // B) Ist es das alte Format (einfaches Array)?
                    else if (Array.isArray(rawData)) {
                        console.log("Legacy Backup erkannt!");
                        tracksToImport = rawData;
                    } else {
                        throw new Error("Unbekanntes Format");
                    }

                    if(!confirm(`Backup einspielen?\n\n‚Ä¢ ${tracksToImport.length} H√∂rb√ºcher\n‚Ä¢ ${statsToImport.length} Statistik-Eintr√§ge\n‚Ä¢ Einstellungen: ${settingsToImport ? "Ja" : "Nein"}`)) return;

                    const tx = db.transaction(["tracks", "stats_log"], "readwrite");
                    const trackStore = tx.objectStore("tracks");
                    const statsStore = tx.objectStore("stats_log");

                    let updated = 0; let newEntries = 0;

                    // 1. Einstellungen wiederherstellen
                    if (settingsToImport) {
                        // Auch in LocalStorage schreiben f√ºr sofortigen Zugriff
                        localStorage.setItem('klangkisteSettings_v16', JSON.stringify(settingsToImport));
                        trackStore.put({ tagId: SYSTEM_SETTINGS_ID, name: "System Settings", data: settingsToImport });
                        
                        // Settings Variable sofort aktualisieren
                        settings = settingsToImport;
                        if(settings.hiddenIDs) hiddenTracks = new Set(settings.hiddenIDs);
                        updateUIFromSettings();
                    }

                    // 2. Statistik wiederherstellen
                    if (statsToImport.length > 0) {
                        // Optional: Alte Statistik vorher l√∂schen? 
                        // statsStore.clear(); // Falls gew√ºnscht, Kommentar entfernen
                        statsToImport.forEach(stat => {
                            // Wir nutzen put statt add, damit keine doppelten IDs Fehler werfen (falls IDs im Backup sind)
                            statsStore.put(stat);
                        });
                    }

                    // 3. Tracks wiederherstellen (mit Erhalt der Audio-Blobs wenn m√∂glich)
                    for(const entry of tracksToImport) {
                          await new Promise((resolve) => {
                            const req = trackStore.get(entry.tagId);
                            req.onsuccess = () => {
                                const existing = req.result;
                                
                                // Wir bauen das neue Objekt
                                const newRecord = {
                                    tagId: entry.tagId,
                                    name: entry.name,
                                    playlistFileNames: entry.playlistFileNames,
                                    imageFileName: entry.imageFileName,
                                    meta: entry.meta,
                                    tags: entry.tags,
                                    filter_age: entry.filter_age,
                                    // Die neuen wichtigen Infos:
                                    lastTrackIndex: entry.lastTrackIndex || 0,
                                    lastTime: entry.lastTime || 0,
                                    completed: entry.completed || false,
                                    hiddenInLib: entry.hiddenInLib || false,
                                    lastPlayedTimestamp: entry.lastPlayedTimestamp || 0,
                                    // Audio/Bild erhalten, wenn es schon da war!
                                    playlist: existing ? existing.playlist : [],
                                    imageBlob: existing ? existing.imageBlob : null,
                                    cueTracks: existing ? existing.cueTracks : null // Oder aus Import wenn erweitert
                                };
                                
                                trackStore.put(newRecord);
                                if(existing) updated++; else newEntries++;
                                resolve();
                            };
                          });
                    }

                    tx.oncomplete = () => {
                        alert(`Wiederherstellung komplett!\n\nStatus: V80 Full Restore\n‚Ä¢ Einstellungen geladen\n‚Ä¢ ${statsToImport.length} Statistik-Events\n‚Ä¢ ${updated} Tracks aktualisiert\n‚Ä¢ ${newEntries} neue Tracks (leer)`);
                        
                        // Wichtig: Da Audio-Blobs im JSON fehlen, leuchten die Buttons evtl. rot (Repair n√∂tig)
                        const btn = document.getElementById('btn-auto-repair'); 
                        if(btn && newEntries > 0) { 
                            btn.style.backgroundColor = "#e74c3c"; 
                            btn.style.animation = "pulse 2s infinite"; 
                            showStatus("Bitte 'Automatisch Reparieren' nutzen f√ºr Audio!");
                        }
                        
                        loadTagList(); 
                        input.value = "";
                    };

                } catch(e) { 
                    alert("Import Fehler: " + e.message); 
                    console.error(e);
                }
            }; 
            reader.readAsText(file);
        }
        
        function parseCueSheet(cueText) {
            const tracks = []; const lines = cueText.split('\n'); let currentTrack = null;
            lines.forEach(line => {
                line = line.trim();
                if (line.startsWith('TRACK')) { currentTrack = {}; }
                if (line.startsWith('TITLE') && currentTrack) { const match = line.match(/"([^"]+)"/); if (match) currentTrack.title = match[1]; }
                if (line.startsWith('INDEX 01') && currentTrack) {
                    const parts = line.split(' '); const timeStr = parts[parts.length - 1]; const timeParts = timeStr.split(':');
                    const min = parseInt(timeParts[0], 10); const sec = parseInt(timeParts[1], 10); const frames = parseInt(timeParts[2], 10);
                    currentTrack.time = (min * 60) + sec + (frames / 75); tracks.push(currentTrack); currentTrack = null;
                }
            }); return tracks;
        }

        function createLibCard(track, isSmall = false) {
            const div = document.createElement('div');
            div.className = isSmall ? 'recent-card' : 'lib-card';
            div.onclick = () => {
                closeLibrary();
                playTrackByTag(track.tagId);
            };

            let imgHtml = `<div class="lib-placeholder">üéµ</div>`;
            if (track.imageBlob) {
                const url = URL.createObjectURL(track.imageBlob);
                activeCoverUrls.push(url); // <--- NEU: Zur L√∂sch-Liste hinzuf√ºgen
                imgHtml = `<img src="${url}" class="lib-cover-img" loading="lazy">`;
            }
            
            let infoBtnHtml = "";
            if(!isSmall) { 
                 infoBtnHtml = `<button class="lib-card-info-btn" onclick="showAlbumInfo(event, '${track.tagId}')">i</button>`;
            }

            let metaInfo = "";
            if(!isSmall && track.meta) {
                 if(track.meta.runtime) metaInfo += `‚è±Ô∏è ${track.meta.runtime} min`;
            }
            
            let completedBadge = "";
            if(track.completed) {
                completedBadge = `<div class="completed-badge">‚úÖ</div>`;
            }

            div.innerHTML = `
                <div class="lib-cover-wrap" style="${isSmall ? 'border-radius:10px;' : ''}">
                    ${imgHtml}
                    ${infoBtnHtml}
                    ${completedBadge}
                </div>
                ${!isSmall ? `
                <div class="lib-card-body">
                    <div class="lib-card-title">${track.name}</div>
                    <span class="lib-meta-tag">${metaInfo}</span>
                </div>` : ''}
            `;
            return div;
        }

        function showAlbumInfo(event, tagId) {
            event.stopPropagation(); 
            const store = db.transaction(["tracks"], "readonly").objectStore("tracks");
            store.get(tagId).onsuccess = (e) => {
                const track = e.target.result;
                if(!track) return;

                const modal = document.getElementById('lib-info-modal');
                const imgEl = document.getElementById('info-modal-img');
                const titleEl = document.getElementById('info-modal-title');
                const metaEl = document.getElementById('info-modal-meta');
                const descEl = document.getElementById('info-modal-desc');

                if(track.imageBlob) imgEl.src = URL.createObjectURL(track.imageBlob);
                else imgEl.src = "";

                titleEl.innerText = track.name;
                
                let metaText = [];
                if(track.meta) {
                    if(track.meta.age_recommendation) metaText.push(`Ab ${track.meta.age_recommendation} J.`);
                    if(track.meta.genre) metaText.push(track.meta.genre);
                    if(track.meta.runtime) metaText.push(`${track.meta.runtime} min`);
                }
                metaEl.innerText = metaText.join(" ‚Ä¢ ");

                if(track.meta && track.meta.description) {
                    descEl.innerText = track.meta.description;
                    descEl.style.display = 'block';
                } else {
                    descEl.style.display = 'none';
                }
                modal.style.display = 'flex';
            };
        }

        function closeAlbumInfo() {
            document.getElementById('lib-info-modal').style.display = 'none';
        }

        // --- LIBRARY MODE LOGIC ---
        let currentLibFilter = 'all';
        let activeCoverUrls = []; // <--- NEU: Liste f√ºr Bild-Speicher

        function openLibrary() {
            if(!db) { showStatus("Datenbank l√§dt..."); return; }
            document.getElementById('library-mode').style.setProperty('display', 'block', 'important');
            renderLibrary();
        }

        function closeLibrary() {
            document.getElementById('library-mode').style.display = 'none';
            // --- REPARATUR: Bilder aus Speicher entfernen wenn Lib zugeht ---
            if(activeCoverUrls.length > 0) {
                activeCoverUrls.forEach(url => URL.revokeObjectURL(url));
                activeCoverUrls = [];
            }
        }

        function renderLibrary() {
            const contentArea = document.getElementById('lib-content-area');
            const filterContainer = document.getElementById('lib-filters');
            contentArea.innerHTML = "";
            
            if(!db) return; 

            const tx = db.transaction(["tracks"], "readonly");
            const store = tx.objectStore("tracks");
            const request = store.getAll();

            request.onsuccess = (e) => {
                let tracks = e.target.result;
                
                tracks = tracks.filter(t => t.tagId !== "system_bg" && t.tagId !== "system_settings");

                // SORTING FIX: SOFORT SORTIEREN
                tracks.sort((a, b) => a.name.localeCompare(b.name, 'de', { sensitivity: 'base' }));

                const ageLimit = (settings.libMaxAge !== undefined) ? settings.libMaxAge : 99;

                tracks = tracks.filter(t => {
                    // SHADOW LIST CHECK
                    if (hiddenTracks.has(t.tagId)) return false; // Wenn in Liste, dann ausblenden
                    
                    const trackAge = (t.meta && t.meta.age_recommendation) ? parseInt(t.meta.age_recommendation) : 0;
                    if (trackAge > ageLimit) return false; 
                    return true;
                });


                if(filterContainer.children.length <= 2) { 
                    const genres = new Set();
                    const ages = new Set();
                    tracks.forEach(t => {
                        if(t.meta && t.meta.genre) genres.add(t.meta.genre);
                        if(t.meta && t.meta.age_recommendation) ages.add(t.meta.age_recommendation);
                    });
                    Array.from(ages).sort((a,b) => a-b).forEach(age => {
                        addFilterChip(`Ab ${age} Jahren`, `age_${age}`);
                    });
                    Array.from(genres).sort().forEach(genre => {
                          addFilterChip(genre, `genre_${genre}`);
                    });
                }

                if (currentLibFilter === 'all' || currentLibFilter === 'recent') {
                    const recentTracks = [...tracks].filter(t => t.lastPlayedTimestamp).sort((a, b) => b.lastPlayedTimestamp - a.lastPlayedTimestamp).slice(0, 3);
                    if (recentTracks.length > 0) {
                        const recentDiv = document.createElement('div');
                        recentDiv.innerHTML = `<div class="section-title">Zuletzt geh√∂rt üïí</div><div class="recent-grid" id="recent-grid-target"></div>`;
                        contentArea.appendChild(recentDiv);
                        const target = recentDiv.querySelector('#recent-grid-target');
                        recentTracks.forEach(t => {
                            target.appendChild(createLibCard(t, true));
                        });
                    }
                }

                if (currentLibFilter === 'recent') return; 

                const gridDiv = document.createElement('div');
                gridDiv.className = 'library-grid';
                if(currentLibFilter === 'all') gridDiv.style.marginTop = "10px";
                
                let filteredTracks = tracks;
                if (currentLibFilter.startsWith('age_')) {
                    const age = parseInt(currentLibFilter.split('_')[1]);
                    filteredTracks = tracks.filter(t => t.meta && t.meta.age_recommendation == age);
                } else if (currentLibFilter.startsWith('genre_')) {
                    const g = currentLibFilter.replace('genre_', '');
                    filteredTracks = tracks.filter(t => t.meta && t.meta.genre === g);
                }

                filteredTracks.forEach(t => {
                    gridDiv.appendChild(createLibCard(t));
                });
                
                contentArea.appendChild(gridDiv);
            };
        }

        function addFilterChip(label, value) {
            const container = document.getElementById('lib-filters');
            if(container.querySelector(`[data-val="${value}"]`)) return;
            const chip = document.createElement('div');
            chip.className = 'filter-chip';
            chip.innerText = label;
            chip.dataset.val = value;
            chip.onclick = function() { applyLibFilter(value, this); };
            container.appendChild(chip);
        }

        function applyLibFilter(filterVal, el) {
            currentLibFilter = filterVal;
            document.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('active'));
            if(el) el.classList.add('active');
            renderLibrary();
        }

        if ('serviceWorker' in navigator) { navigator.serviceWorker.register('sw.js'); }
    </script>
</body>
</html>
